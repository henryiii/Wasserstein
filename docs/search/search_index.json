{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Wasserstein Features The Wasserstein package computes Wasserstein distances and related quantities efficiently. It contains an efficient implementation of the network simplex algorithm originally written by Nicolas Boneel , modified by the authors of the Python Optimal Transport (POT) library, and further modified in this package by Patrick Komiske. The main code is written in C++ with a Python wrapper provided via SWIG . The following classes contain the main functionalities of Wasserstein: EMD : EFPs are a collection of jet substructure observables which form a complete linear basis of IRC-safe observables. EnergyFlow provides tools to compute EFPs on events for several energy and angular measures as well as custom measures. PairwiseEMD : EFNs are infrared- and collinear-safe models designed for learning from collider events as unordered, variable-length sets of particles. EnergyFlow contains customizable Keras implementations of EFNs. Available from version 0.10.0 onward. CorrelationDimension : PFNs are general models designed for learning from collider events as unordered, variable-length sets of particles, based on the Deep Sets framework. EnergyFlow contains customizable Keras implementations of PFNs. Available from version 0.10.0 onward. The current version is 0.2.0 . Changes are summarized in the Release Notes . Using the most up-to-date version is recommended. As of version 0.2.0 , tests have been written covering the majority of the code. The source code can be found on GitHub . Get started by installing EnergyFlow , exploring the demos , and running the examples ! References [1] P. T. Komiske, E. M. Metodiev, and J. Thaler, The Metric Space of Collider Events , Phys. Rev. Lett. 123 (2019) 041801 [ 1902.02346 ]. [2] P. T. Komiske, E. M. Metodiev, and J. Thaler, The Hidden Geometry of Particle Collisions , JHEP 07 (2020) 006 [ 2004.04159 ]. Copyright Wasserstein is licensed under GPLv3 . See the LICENSE for detailed copyright information. EnergyFlow uses a customized einsumfunc.py from the NumPy GitHub repository as well as a few functions relating to downloading files copied from the Keras GitHub repository. The copyrights for these parts of the code are attributed to their respective owners in the LICENSE file.","title":"Home"},{"location":"#welcome-to-wasserstein","text":"","title":"Welcome to Wasserstein"},{"location":"#features","text":"The Wasserstein package computes Wasserstein distances and related quantities efficiently. It contains an efficient implementation of the network simplex algorithm originally written by Nicolas Boneel , modified by the authors of the Python Optimal Transport (POT) library, and further modified in this package by Patrick Komiske. The main code is written in C++ with a Python wrapper provided via SWIG . The following classes contain the main functionalities of Wasserstein: EMD : EFPs are a collection of jet substructure observables which form a complete linear basis of IRC-safe observables. EnergyFlow provides tools to compute EFPs on events for several energy and angular measures as well as custom measures. PairwiseEMD : EFNs are infrared- and collinear-safe models designed for learning from collider events as unordered, variable-length sets of particles. EnergyFlow contains customizable Keras implementations of EFNs. Available from version 0.10.0 onward. CorrelationDimension : PFNs are general models designed for learning from collider events as unordered, variable-length sets of particles, based on the Deep Sets framework. EnergyFlow contains customizable Keras implementations of PFNs. Available from version 0.10.0 onward. The current version is 0.2.0 . Changes are summarized in the Release Notes . Using the most up-to-date version is recommended. As of version 0.2.0 , tests have been written covering the majority of the code. The source code can be found on GitHub . Get started by installing EnergyFlow , exploring the demos , and running the examples !","title":"Features"},{"location":"#references","text":"[1] P. T. Komiske, E. M. Metodiev, and J. Thaler, The Metric Space of Collider Events , Phys. Rev. Lett. 123 (2019) 041801 [ 1902.02346 ]. [2] P. T. Komiske, E. M. Metodiev, and J. Thaler, The Hidden Geometry of Particle Collisions , JHEP 07 (2020) 006 [ 2004.04159 ].","title":"References"},{"location":"#copyright","text":"Wasserstein is licensed under GPLv3 . See the LICENSE for detailed copyright information. EnergyFlow uses a customized einsumfunc.py from the NumPy GitHub repository as well as a few functions relating to downloading files copied from the Keras GitHub repository. The copyrights for these parts of the code are attributed to their respective owners in the LICENSE file.","title":"Copyright"},{"location":"demos/","text":"Interactive Demos The following Jupyter notebook demo is available on GitHub. Binder provides an awesome platform for running it durectly in your browser without installing anything whatsoever. For C++ usage, check out the Examples . Wasserstein Demo The Wasserstein Demo provides an introduction to using the Wasserstein package to compute Wasserstein/distances. View or download the notebook from GitHub","title":"Python Demos"},{"location":"demos/#interactive-demos","text":"The following Jupyter notebook demo is available on GitHub. Binder provides an awesome platform for running it durectly in your browser without installing anything whatsoever. For C++ usage, check out the Examples .","title":"Interactive Demos"},{"location":"demos/#wasserstein-demo","text":"The Wasserstein Demo provides an introduction to using the Wasserstein package to compute Wasserstein/distances. View or download the notebook from GitHub","title":"Wasserstein Demo"},{"location":"examples/","text":"","title":"C++ Examples"},{"location":"faqs/","text":"Frequently Asked EnergyFlow Questions How do I cite the EnergyFlow package? How do I cite the datasets available through EnergyFlow? Why Python instead of C++? Can I contribute to the code? How do I report an issue or a bug? Where can I get graph image files? How do I cite the EnergyFlow package? Please cite the relevant papers if they or this package help your research. Here are the BibTeX entries to use: @article{Komiske:2017aww, author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\", title = \"{Energy flow polynomials: A complete linear basis for jet substructure}\", eprint = \"1712.07124\", archivePrefix = \"arXiv\", primaryClass = \"hep-ph\", reportNumber = \"MIT-CTP-4965\", doi = \"10.1007/JHEP04(2018)013\", journal = \"JHEP\", volume = \"04\", pages = \"013\", year = \"2018\" } @article{Komiske:2018cqr, author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\", title = \"{Energy Flow Networks: Deep Sets for Particle Jets}\", eprint = \"1810.05165\", archivePrefix = \"arXiv\", primaryClass = \"hep-ph\", reportNumber = \"MIT-CTP 5064\", doi = \"10.1007/JHEP01(2019)121\", journal = \"JHEP\", volume = \"01\", pages = \"121\", year = \"2019\" } @article{Komiske:2019fks, author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\", title = \"{Metric Space of Collider Events}\", eprint = \"1902.02346\", archivePrefix = \"arXiv\", primaryClass = \"hep-ph\", reportNumber = \"MIT-CTP 5102\", doi = \"10.1103/PhysRevLett.123.041801\", journal = \"Phys. Rev. Lett.\", volume = \"123\", number = \"4\", pages = \"041801\", year = \"2019\" } @article{Komiske:2019jim, author = \"Komiske, Patrick T. and Mastandrea, Radha and Metodiev, Eric M. and Naik, Preksha and Thaler, Jesse\", title = \"{Exploring the Space of Jets with CMS Open Data}\", eprint = \"1908.08542\", archivePrefix = \"arXiv\", primaryClass = \"hep-ph\", reportNumber = \"MIT-CTP 5129\", doi = \"10.1103/PhysRevD.101.034009\", journal = \"Phys. Rev. D\", volume = \"101\", number = \"3\", pages = \"034009\", year = \"2020\" } @article{Komiske:2019asc, author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\", title = \"{Cutting Multiparticle Correlators Down to Size}\", eprint = \"1911.04491\", archivePrefix = \"arXiv\", primaryClass = \"hep-ph\", reportNumber = \"MIT-CTP 5150\", doi = \"10.1103/PhysRevD.101.036019\", journal = \"Phys. Rev. D\", volume = \"101\", number = \"3\", pages = \"036019\", year = \"2020\" } @article{Andreassen:2019cjw, author = \"Andreassen, Anders and Komiske, Patrick T. and Metodiev, Eric M. and Nachman, Benjamin and Thaler, Jesse\", title = \"{OmniFold: A Method to Simultaneously Unfold All Observables}\", eprint = \"1911.09107\", archivePrefix = \"arXiv\", primaryClass = \"hep-ph\", reportNumber = \"MIT-CTP 5155\", doi = \"10.1103/PhysRevLett.124.182001\", journal = \"Phys. Rev. Lett.\", volume = \"124\", number = \"18\", pages = \"182001\", year = \"2020\" } @article{Komiske:2020qhg, author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\", title = \"{The Hidden Geometry of Particle Collisions}\", eprint = \"2004.04159\", archivePrefix = \"arXiv\", primaryClass = \"hep-ph\", reportNumber = \"MIT-CTP 5185\", doi = \"10.1007/JHEP07(2020)006\", journal = \"JHEP\", volume = \"07\", pages = \"006\", year = \"2020\" } How do I cite the datasets available through EnergyFlow? If any of the datasets provided through EnergyFlow are used in your research, we ask that you cite their Zenodo records, which are provided below in BibTeX format (confirmed to give a sensible citation in the JHEP and RevTeX bibliography styles). CMS Open Data in MOD HDF5 Format @article{Zenodo:MODCMS2011A:Jets, author = {Komiske, Patrick and Mastandrea, Radha and Metodiev, Eric and Naik, Preksha and Thaler, Jesse}, title = {{CMS 2011A Open Data $|$ Jet Primary Dataset $|$ pT $>$ 375 GeV $|$ MOD HDF5 Format}}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3340205} } @article{Zenodo:MODCMS2011A:MC170, author = {Komiske, Patrick and Mastandrea, Radha and Metodiev, Eric and Naik, Preksha and Thaler, Jesse}, title = {{CMS 2011A Simulation $|$ Pythia 6 QCD 170-300 $|$ pT $>$ 375 GeV $|$ MOD HDF5 Format}}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3341500} } @article{Zenodo:MODCMS2011A:MC300, author = {Komiske, Patrick and Mastandrea, Radha and Metodiev, Eric and Naik, Preksha and Thaler, Jesse}, title = {{CMS 2011A Simulation $|$ Pythia 6 QCD 300-470 $|$ pT $>$ 375 GeV $|$ MOD HDF5 Format}}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3341498} } @article{Zenodo:MODCMS2011A:MC470, author = {Komiske, Patrick and Mastandrea, Radha and Metodiev, Eric and Naik, Preksha and Thaler, Jesse}, title = {{CMS 2011A Simulation $|$ Pythia 6 QCD 470-600 $|$ pT $>$ 375 GeV $|$ MOD HDF5 Format}}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3341419} } @article{Zenodo:MODCMS2011A:MC600, author = {Komiske, Patrick and Mastandrea, Radha and Metodiev, Eric and Naik, Preksha and Thaler, Jesse}, title = {{CMS 2011A Simulation $|$ Pythia 6 QCD 600-800 $|$ pT $>$ 375 GeV $|$ MOD HDF5 Format}}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3364139} } @article{Zenodo:MODCMS2011A:MC800, author = {Komiske, Patrick and Mastandrea, Radha and Metodiev, Eric and Naik, Preksha and Thaler, Jesse}, title = {{CMS 2011A Simulation $|$ Pythia 6 QCD 800-1000 $|$ pT $>$ 375 GeV $|$ MOD HDF5 Format}}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3341413} } @article{Zenodo:MODCMS2011A:MC1000, author = {Komiske, Patrick and Mastandrea, Radha and Metodiev, Eric and Naik, Preksha and Thaler, Jesse}, title = {{CMS 2011A Simulation $|$ Pythia 6 QCD 1000-1400 $|$ pT $>$ 375 GeV $|$ MOD HDF5 Format}}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3341502} } @article{Zenodo:MODCMS2011A:MC1400, author = {Komiske, Patrick and Mastandrea, Radha and Metodiev, Eric and Naik, Preksha and Thaler, Jesse}, title = {{CMS 2011A Simulation $|$ Pythia 6 QCD 1400-1800 $|$ pT $>$ 375 GeV $|$ MOD HDF5 Format}}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3341770} } @article{Zenodo:MODCMS2011A:MC1800, author = {Komiske, Patrick and Mastandrea, Radha and Metodiev, Eric and Naik, Preksha and Thaler, Jesse}, title = {{CMS 2011A Simulation $|$ Pythia 6 QCD1800-inf $|$ pT $>$ 375 GeV $|$ MOD HDF5 Format}}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3341772} } - CMS 2011A Jets, pT > 375 GeV - SIM/GEN QCD Jets 170-300 GeV - SIM/GEN QCD Jets 300-470 GeV - SIM/GEN QCD Jets 470-600 GeV - SIM/GEN QCD Jets 600-800 GeV - SIM/GEN QCD Jets 800-1000 GeV - SIM/GEN QCD Jets 1000-1400 GeV - SIM/GEN QCD Jets 1400-1800 GeV - SIM/GEN QCD Jets 1800-$\\infty$ GeV Quark and Gluon Datasets @article{Zenodo:EnergyFlow:Pythia8QGs, author = {Komiske, Patrick and Metodiev, Eric and Thaler, Jesse}, title = {Pythia8 Quark and Gluon Jets for Energy Flow}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3164691} } @article{Zenodo:EnergyFlow:Herwig7QGs, author = {Pathak, Aditya and Komiske, Patrick and Metodiev, Eric and Schwartz, Matthew}, title = {Herwig7.1 Quark and Gluon Jets}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3066475} } - Pythia samples - Herwig samples Z + Jets with Delphes Datasets @article{Zenodo:EnergyFlow:ZJetsDelphes, author = {Andreassen, Anders and Komiske, Patrick and Metodiev, Eric and Nachman, Benjamin and Thaler, Jesse}, title = {{Pythia/Herwig + Delphes Jet Datasets for OmniFold Unfolding}}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3548091} } - Pythia/Herwig + Delphes samples Why Python instead of C++? Computing the EFPs requires a function such as NumPy's einsum that can efficiently evaluate arbitrary tensor contractions. To write such a function from scratch in C++ is difficult, and there is no obvious library in C++ to use (though if one were to attempt this the tensor algebra compiler seems like a promising tool). NumPy is a highly-optimized Python library written in C that provides all of the tools required to efficiently compute the EFPs. Libraries like NumPy take advantage of optimizations that the physicist-programmer typically does not, such as architecture-optimized libraries like BLAS or LAPACK and low-level features such as SSE/AVX instructions. Beyond just computing EFPs, EnergyFlow makes use of other libraries written in python including Keras and scikit-learn for the architecture implementations, POT and SciPy for EMD computations, and matplotlib for the examples. Can I contribute to the code? All of our code is open source and hosted on GitHub . We welcome additional contributors, and if you are interested in getting involved please contact us directly. Contact information is included in the relevant Energy Flow papers and our GitHub repository. How do I report an issue? Please let us know of any issues you encounter as soon as possible by creating a GitHub Issue . Where can I get graph image files? Image files for all connected multigraphs with up to 7 edges in the EFP style are available as PDF files here . You are free to use them with the proper attribution.","title":"FAQs"},{"location":"faqs/#frequently-asked-energyflow-questions","text":"How do I cite the EnergyFlow package? How do I cite the datasets available through EnergyFlow? Why Python instead of C++? Can I contribute to the code? How do I report an issue or a bug? Where can I get graph image files?","title":"Frequently Asked EnergyFlow Questions"},{"location":"faqs/#how-do-i-cite-the-energyflow-package","text":"Please cite the relevant papers if they or this package help your research. Here are the BibTeX entries to use: @article{Komiske:2017aww, author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\", title = \"{Energy flow polynomials: A complete linear basis for jet substructure}\", eprint = \"1712.07124\", archivePrefix = \"arXiv\", primaryClass = \"hep-ph\", reportNumber = \"MIT-CTP-4965\", doi = \"10.1007/JHEP04(2018)013\", journal = \"JHEP\", volume = \"04\", pages = \"013\", year = \"2018\" } @article{Komiske:2018cqr, author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\", title = \"{Energy Flow Networks: Deep Sets for Particle Jets}\", eprint = \"1810.05165\", archivePrefix = \"arXiv\", primaryClass = \"hep-ph\", reportNumber = \"MIT-CTP 5064\", doi = \"10.1007/JHEP01(2019)121\", journal = \"JHEP\", volume = \"01\", pages = \"121\", year = \"2019\" } @article{Komiske:2019fks, author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\", title = \"{Metric Space of Collider Events}\", eprint = \"1902.02346\", archivePrefix = \"arXiv\", primaryClass = \"hep-ph\", reportNumber = \"MIT-CTP 5102\", doi = \"10.1103/PhysRevLett.123.041801\", journal = \"Phys. Rev. Lett.\", volume = \"123\", number = \"4\", pages = \"041801\", year = \"2019\" } @article{Komiske:2019jim, author = \"Komiske, Patrick T. and Mastandrea, Radha and Metodiev, Eric M. and Naik, Preksha and Thaler, Jesse\", title = \"{Exploring the Space of Jets with CMS Open Data}\", eprint = \"1908.08542\", archivePrefix = \"arXiv\", primaryClass = \"hep-ph\", reportNumber = \"MIT-CTP 5129\", doi = \"10.1103/PhysRevD.101.034009\", journal = \"Phys. Rev. D\", volume = \"101\", number = \"3\", pages = \"034009\", year = \"2020\" } @article{Komiske:2019asc, author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\", title = \"{Cutting Multiparticle Correlators Down to Size}\", eprint = \"1911.04491\", archivePrefix = \"arXiv\", primaryClass = \"hep-ph\", reportNumber = \"MIT-CTP 5150\", doi = \"10.1103/PhysRevD.101.036019\", journal = \"Phys. Rev. D\", volume = \"101\", number = \"3\", pages = \"036019\", year = \"2020\" } @article{Andreassen:2019cjw, author = \"Andreassen, Anders and Komiske, Patrick T. and Metodiev, Eric M. and Nachman, Benjamin and Thaler, Jesse\", title = \"{OmniFold: A Method to Simultaneously Unfold All Observables}\", eprint = \"1911.09107\", archivePrefix = \"arXiv\", primaryClass = \"hep-ph\", reportNumber = \"MIT-CTP 5155\", doi = \"10.1103/PhysRevLett.124.182001\", journal = \"Phys. Rev. Lett.\", volume = \"124\", number = \"18\", pages = \"182001\", year = \"2020\" } @article{Komiske:2020qhg, author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\", title = \"{The Hidden Geometry of Particle Collisions}\", eprint = \"2004.04159\", archivePrefix = \"arXiv\", primaryClass = \"hep-ph\", reportNumber = \"MIT-CTP 5185\", doi = \"10.1007/JHEP07(2020)006\", journal = \"JHEP\", volume = \"07\", pages = \"006\", year = \"2020\" }","title":"How do I cite the EnergyFlow package?"},{"location":"faqs/#how-do-i-cite-the-datasets-available-through-energyflow","text":"If any of the datasets provided through EnergyFlow are used in your research, we ask that you cite their Zenodo records, which are provided below in BibTeX format (confirmed to give a sensible citation in the JHEP and RevTeX bibliography styles). CMS Open Data in MOD HDF5 Format @article{Zenodo:MODCMS2011A:Jets, author = {Komiske, Patrick and Mastandrea, Radha and Metodiev, Eric and Naik, Preksha and Thaler, Jesse}, title = {{CMS 2011A Open Data $|$ Jet Primary Dataset $|$ pT $>$ 375 GeV $|$ MOD HDF5 Format}}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3340205} } @article{Zenodo:MODCMS2011A:MC170, author = {Komiske, Patrick and Mastandrea, Radha and Metodiev, Eric and Naik, Preksha and Thaler, Jesse}, title = {{CMS 2011A Simulation $|$ Pythia 6 QCD 170-300 $|$ pT $>$ 375 GeV $|$ MOD HDF5 Format}}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3341500} } @article{Zenodo:MODCMS2011A:MC300, author = {Komiske, Patrick and Mastandrea, Radha and Metodiev, Eric and Naik, Preksha and Thaler, Jesse}, title = {{CMS 2011A Simulation $|$ Pythia 6 QCD 300-470 $|$ pT $>$ 375 GeV $|$ MOD HDF5 Format}}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3341498} } @article{Zenodo:MODCMS2011A:MC470, author = {Komiske, Patrick and Mastandrea, Radha and Metodiev, Eric and Naik, Preksha and Thaler, Jesse}, title = {{CMS 2011A Simulation $|$ Pythia 6 QCD 470-600 $|$ pT $>$ 375 GeV $|$ MOD HDF5 Format}}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3341419} } @article{Zenodo:MODCMS2011A:MC600, author = {Komiske, Patrick and Mastandrea, Radha and Metodiev, Eric and Naik, Preksha and Thaler, Jesse}, title = {{CMS 2011A Simulation $|$ Pythia 6 QCD 600-800 $|$ pT $>$ 375 GeV $|$ MOD HDF5 Format}}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3364139} } @article{Zenodo:MODCMS2011A:MC800, author = {Komiske, Patrick and Mastandrea, Radha and Metodiev, Eric and Naik, Preksha and Thaler, Jesse}, title = {{CMS 2011A Simulation $|$ Pythia 6 QCD 800-1000 $|$ pT $>$ 375 GeV $|$ MOD HDF5 Format}}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3341413} } @article{Zenodo:MODCMS2011A:MC1000, author = {Komiske, Patrick and Mastandrea, Radha and Metodiev, Eric and Naik, Preksha and Thaler, Jesse}, title = {{CMS 2011A Simulation $|$ Pythia 6 QCD 1000-1400 $|$ pT $>$ 375 GeV $|$ MOD HDF5 Format}}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3341502} } @article{Zenodo:MODCMS2011A:MC1400, author = {Komiske, Patrick and Mastandrea, Radha and Metodiev, Eric and Naik, Preksha and Thaler, Jesse}, title = {{CMS 2011A Simulation $|$ Pythia 6 QCD 1400-1800 $|$ pT $>$ 375 GeV $|$ MOD HDF5 Format}}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3341770} } @article{Zenodo:MODCMS2011A:MC1800, author = {Komiske, Patrick and Mastandrea, Radha and Metodiev, Eric and Naik, Preksha and Thaler, Jesse}, title = {{CMS 2011A Simulation $|$ Pythia 6 QCD1800-inf $|$ pT $>$ 375 GeV $|$ MOD HDF5 Format}}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3341772} } - CMS 2011A Jets, pT > 375 GeV - SIM/GEN QCD Jets 170-300 GeV - SIM/GEN QCD Jets 300-470 GeV - SIM/GEN QCD Jets 470-600 GeV - SIM/GEN QCD Jets 600-800 GeV - SIM/GEN QCD Jets 800-1000 GeV - SIM/GEN QCD Jets 1000-1400 GeV - SIM/GEN QCD Jets 1400-1800 GeV - SIM/GEN QCD Jets 1800-$\\infty$ GeV Quark and Gluon Datasets @article{Zenodo:EnergyFlow:Pythia8QGs, author = {Komiske, Patrick and Metodiev, Eric and Thaler, Jesse}, title = {Pythia8 Quark and Gluon Jets for Energy Flow}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3164691} } @article{Zenodo:EnergyFlow:Herwig7QGs, author = {Pathak, Aditya and Komiske, Patrick and Metodiev, Eric and Schwartz, Matthew}, title = {Herwig7.1 Quark and Gluon Jets}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3066475} } - Pythia samples - Herwig samples Z + Jets with Delphes Datasets @article{Zenodo:EnergyFlow:ZJetsDelphes, author = {Andreassen, Anders and Komiske, Patrick and Metodiev, Eric and Nachman, Benjamin and Thaler, Jesse}, title = {{Pythia/Herwig + Delphes Jet Datasets for OmniFold Unfolding}}, journal = \"Zenodo\", year = 2019, doi = {10.5281/zenodo.3548091} } - Pythia/Herwig + Delphes samples","title":"How do I cite the datasets available through EnergyFlow?"},{"location":"faqs/#why-python-instead-of-c","text":"Computing the EFPs requires a function such as NumPy's einsum that can efficiently evaluate arbitrary tensor contractions. To write such a function from scratch in C++ is difficult, and there is no obvious library in C++ to use (though if one were to attempt this the tensor algebra compiler seems like a promising tool). NumPy is a highly-optimized Python library written in C that provides all of the tools required to efficiently compute the EFPs. Libraries like NumPy take advantage of optimizations that the physicist-programmer typically does not, such as architecture-optimized libraries like BLAS or LAPACK and low-level features such as SSE/AVX instructions. Beyond just computing EFPs, EnergyFlow makes use of other libraries written in python including Keras and scikit-learn for the architecture implementations, POT and SciPy for EMD computations, and matplotlib for the examples.","title":"Why Python instead of C++?"},{"location":"faqs/#can-i-contribute-to-the-code","text":"All of our code is open source and hosted on GitHub . We welcome additional contributors, and if you are interested in getting involved please contact us directly. Contact information is included in the relevant Energy Flow papers and our GitHub repository.","title":"Can I contribute to the code?"},{"location":"faqs/#how-do-i-report-an-issue","text":"Please let us know of any issues you encounter as soon as possible by creating a GitHub Issue .","title":"How do I report an issue?"},{"location":"faqs/#where-can-i-get-graph-image-files","text":"Image files for all connected multigraphs with up to 7 edges in the EFP style are available as PDF files here . You are free to use them with the proper attribution.","title":"Where can I get graph image files?"},{"location":"installation/","text":"Installation The Wasserstein package can be used as a header-only C++ template library or as a Python package that wraps the C++ code. Python Install via pip Precompiled Python wheels are available for Linux, maxOS, and Windows via PyPI. The only strict dependency is NumPy, though Wurlitzer is also installed in order to redirect standard output into Jupyter notebooks in the demos. Simply run the following in a terminal to install Wasserstein: pip3 install wasserstein Install from Python source The only reason to bother with the source code when using Wasserstein in Python is if one wants to develop some feature in the package. The Wasserstein source code can be obtained from GitHub . Running python3 setup.py swig (which requires the swig binary to be available on the path) will regenerate the Python wrapper code. Running python3 setup.py build_ext --inplace will compile the library, and pip3 install -e . will install a development version pointing to the current directory. C++ The Wasserstein source code can be obtained from GitHub . Since the library is header-only, no compilation is required to install it. The provided install_wasserstein.sh script can be used (on a UNIX-like system, at least) to move the requisite header files to an appropriate location such as /usr/local/include . If your system does not have the Boost libraries (version 1.70.0 or newer is required to access the histogram package) available, set the second argument to true in order to use the provided Boost Histogram header files. Try the following in order to move the Wasserstein header files to an installed location, in this case /usr/local/include : git clone https://github.com/pkomiske/Wasserstein cd Wasserstein chmod +x install_wasserstein.sh ./install_wasserstein /usr/local false","title":"Installation"},{"location":"installation/#installation","text":"The Wasserstein package can be used as a header-only C++ template library or as a Python package that wraps the C++ code.","title":"Installation"},{"location":"installation/#python","text":"","title":"Python"},{"location":"installation/#install-via-pip","text":"Precompiled Python wheels are available for Linux, maxOS, and Windows via PyPI. The only strict dependency is NumPy, though Wurlitzer is also installed in order to redirect standard output into Jupyter notebooks in the demos. Simply run the following in a terminal to install Wasserstein: pip3 install wasserstein","title":"Install via pip"},{"location":"installation/#install-from-python-source","text":"The only reason to bother with the source code when using Wasserstein in Python is if one wants to develop some feature in the package. The Wasserstein source code can be obtained from GitHub . Running python3 setup.py swig (which requires the swig binary to be available on the path) will regenerate the Python wrapper code. Running python3 setup.py build_ext --inplace will compile the library, and pip3 install -e . will install a development version pointing to the current directory.","title":"Install from Python source"},{"location":"installation/#c","text":"The Wasserstein source code can be obtained from GitHub . Since the library is header-only, no compilation is required to install it. The provided install_wasserstein.sh script can be used (on a UNIX-like system, at least) to move the requisite header files to an appropriate location such as /usr/local/include . If your system does not have the Boost libraries (version 1.70.0 or newer is required to access the histogram package) available, set the second argument to true in order to use the provided Boost Histogram header files. Try the following in order to move the Wasserstein header files to an installed location, in this case /usr/local/include : git clone https://github.com/pkomiske/Wasserstein cd Wasserstein chmod +x install_wasserstein.sh ./install_wasserstein /usr/local false","title":"C++"},{"location":"releases/","text":"Release Notes","title":"Release Notes"},{"location":"releases/#release-notes","text":"","title":"Release Notes"},{"location":"docs/correlationdimension/","text":"","title":"CorrelationDimension"},{"location":"docs/emd/","text":"Energy Mover's Distance The Energy Mover's Distance (EMD), also known as the Earth Mover's Distance, is a metric between particle collider events introduced in 1902.02346 . This submodule contains convenient functions for computing EMDs between individual events and collections of events. The core of the computation is handled by either the Wasserstein library or the Python Optimal Transport (POT) library, one of which must be installed in order to use this submodule. From Eqs. (1.2) and (1.3) in 2004.04159 , the EMD between two events is the minimum ''work'' required to rearrange one event $\\mathcal E$ into the other $\\mathcal E'$ by movements of energy $f_{ij}$ from particle $i$ in one event to particle $j$ in the other: \\text{EMD}_{\\beta,R}(\\mathcal E,\\mathcal E^\\prime)=\\min_{\\{f_{ij}\\ge0\\}}\\sum_{i=1}^M\\sum_{j=1}^{M'}f_{ij}\\left(\\frac{ \\theta_{ij}}{R}\\right)^\\beta + \\left|\\sum_{i=1}^ME_i-\\sum_{j=1}^{M'}E^\\prime_j \\right|,\\\\\\sum_{j=1}^{M'}f_{ij}\\le E_i, \\quad \\sum_{i=1}^Mf_{ij}\\le E^\\prime_j, \\quad\\sum_{i=1}^M\\sum_{j=1}^{M'}f_{ij}=E_\\text{min}, where $E_i,E^\\prime_j$ are the energies of the particles in the two events, $\\theta_{ij}$ is an angular distance between particles, and $E_\\text{min}=\\min\\left(\\sum_{i=1}^ME_i,\\,\\sum_{j=1}^{M'}E^\\prime_j\\right)$ is the smaller of the two total energies. In a hadronic context, transverse momenta are used instead of energies. emd energyflow.emd.emd(*args, **kwargs) Computes the EMD between two events. The emd function is set equal to either emd_wasserstein or emd_pot , with the former preferred unless the Wasserstein library is not available. emds energyflow.emd.emds(*args, **kwargs) Computes the EMDs between collections of events. The emds function is set equal to either emds_wasserstein or emds_pot , with the former preferred unless the Wasserstein library is not available. emd_wasserstein energyflow.emd.emd_wasserstein(ev0, ev1, dists=None, R=1.0, beta=1.0, norm=False, gdim=2, mask=False, return_flow=False, do_timing=False, n_iter_max=100000, epsilon_large_factor=10000.0, epsilon_small_factor=1.0) Compute the EMD between two events using the Wasserstein library. Arguments ev0 : numpy.ndarray The first event, given as a two-dimensional array. The event is assumed to be an (M,1+gdim) array of particles, where M is the multiplicity and gdim is the dimension of the ground space in which to compute euclidean distances between particles (as specified by the gdim keyword argument). The zeroth column is the weights of the particles, typically their energies or transverse momenta. For typical hadron collider jet applications, each particle will be of the form (pT,y,phi) where y is the rapidity and phi is the azimuthal angle. If dists are provided, then the columns after the zeroth are ignored; alternatively a one-dimensional array consisting of just the particle weights may be passed in this case. ev1 : numpy.ndarray The other event, same format as ev0 . dists : numpy.ndarray A distance matrix between particles in ev0 and ev1 . If None , then the columns of the events after the zeroth are taken to be coordinates and the gdim -dimensional Euclidean distance is used. R : float The R parameter in the EMD definition that controls the relative importance of the two terms. Must be greater than or equal to half of the maximum ground distance in the space in order for the EMD to be a valid metric satisfying the triangle inequality. beta : float The angular weighting exponent. The internal pairwsie distance matrix is raised to this power prior to solving the optimal transport problem. norm : bool Whether or not to normalize the particle weights to sum to one prior to computing the EMD. gdim : int The dimension of the ground metric space. Useful for restricting which dimensions are considered part of the ground space when using the internal euclidean distances between particles. Has no effect if dists are provided. return_flow : bool Whether or not to return the flow matrix describing the optimal transport found during the computation of the EMD. Note that since the second term in Eq. 1 is implemented by including an additional particle in the event with lesser total weight, this will be reflected in the flow matrix. mask : bool If True , masks out particles farther than R away from the origin. Has no effect if dists are provided. n_iter_max : int Maximum number of iterations for solving the optimal transport problem. epsilon_large_factor : float Controls some tolerances in the optimal transport solver. This value is multiplied by the floating points epsilon (around 1e-16 for 64-bit floats) to determine the actual tolerance. epsilon_small_factor : float Analogou to epsilon_large_factor but used where the numerical tolerance can be stricter. Returns float The EMD value. [ numpy.ndarray ], optional The flow matrix found while solving for the EMD. The (i,j) th entry is the amount of pT that flows between particle i in ev0 and particle j in ev1 . emds_wasserstein energyflow.emd.emds_wasserstein(events0, events1=None, R=1.0, beta=1.0, norm=False, gdim=2, mask=False, external_emd_handler=None, n_jobs=-1, print_every=0, verbose=0, throw_on_error=True, n_iter_max=100000, epsilon_large_factor=10000.0, epsilon_small_factor=1.0) Compute the EMDs between collections of events. This can be used to compute EMDs between all pairs of events in a set or between events in two different sets. Arguments events0 : list Iterable collection of events. Each event is assumed to be an (M,1+gdim) array of particles, where M is the multiplicity and gdim is the dimension of the ground space in which to compute euclidean distances between particles (as specified by the gdim keyword argument). The zeroth column is the weights of the particles, typically their energies or transverse momenta. For typical hadron collider jet applications, each particle will be of the form (pT,y,phi) where y is the rapidity and phi is the azimuthal angle. If dists are provided, then the columns after the zeroth are ignored; alternatively a one-dimensional array consisting of just the particle weights may be passed in this case. events1 : list or None Iterable collection of events in the same format as events0 , or None . If the latter, the pairwise distances between events in events0 will be computed and the returned matrix will be symmetric. R : float The R parameter in the EMD definition that controls the relative importance of the two terms. Must be greater than or equal to half of the maximum ground distance in the space in order for the EMD to be a valid metric satisfying the triangle inequality. norm : bool Whether or not to normalize the particle weights to sum to one prior to computing the EMD. beta : float The angular weighting exponent. The internal pairwsie distance matrix is raised to this power prior to solving the optimal transport problem. gdim : int The dimension of the ground metric space. Useful for restricting which dimensions are considered part of the ground space when using the internal euclidean distances between particles. mask : bool If True , ignores particles farther than R away from the origin. external_emd_handler : wasserstein.ExternalEMDHandler An instance of an external EMD handler from the wasserstein module, e.g. CorrelationDimension . n_jobs : int or None The number of cpu cores to use. A value of None or -1 will use as many threads as there are CPUs on the machine. print_every : int The number of computations to do in between printing the progress. Even if the verbosity level is zero, this still plays a role in determining when the worker threads report the results back to the main thread and check for interrupt signals. verbose : int Controls the verbosity level. A value greater than 0 will print the progress of the computation at intervals specified by print_every . throw_on_error : bool Whether or not to raise an exception when an issue is encountered. Can be useful when debugging. n_iter_max : int Maximum number of iterations for solving the optimal transport problem. epsilon_large_factor : float Controls some tolerances in the optimal transport solver. This value is multiplied by the floating points epsilon (around 1e-16 for 64-bit floats) to determine the actual tolerance. epsilon_small_factor : float Analogou to epsilon_large_factor but used where the numerical tolerance can be stricter. Returns numpy.ndarray The EMD values as a two-dimensional array, except if an external EMD handler was provided, in which case no value is returned. If events1 was None , then the shape will be (len(events0), len(events0)) and the array will be symmetric, otherwise it will have shape (len(events0), len(events1)) . emd_pot energyflow.emd.emd_pot(ev0, ev1, R=1.0, norm=False, beta=1.0, measure='euclidean', coords='hadronic', return_flow=False, gdim=None, mask=False, n_iter_max=100000, periodic_phi=False, phi_col=2, empty_policy='error') Compute the EMD between two events using the Python Optimal Transport library. Arguments ev0 : numpy.ndarray The first event, given as a two-dimensional array. The event is assumed to be an (M,1+gdim) array of particles, where M is the multiplicity and gdim is the dimension of the ground space in which to compute euclidean distances between particles (as specified by the gdim keyword argument. The zeroth column is assumed to be the energies (or equivalently, the transverse momenta) of the particles. For typical hadron collider jet applications, each particle will be of the form (pT,y,phi) where y is the rapidity and phi is the azimuthal angle. ev1 : numpy.ndarray The other event, same format as ev0 . R : float The R parameter in the EMD definition that controls the relative importance of the two terms. Must be greater than or equal to half of the maximum ground distance in the space in order for the EMD to be a valid metric satisfying the triangle inequality. beta : float The angular weighting exponent. The internal pairwsie distance matrix is raised to this power prior to solving the optimal transport problem. norm : bool Whether or not to normalize the pT values of the events prior to computing the EMD. measure : str Controls which metric is used to calculate the ground distances between particles. 'euclidean' uses the euclidean metric in however many dimensions are provided and specified by gdim . 'spherical' uses the opening angle between particles on the sphere (note that this is not fully tested and should be used cautiously). coords : str Only has an effect if measure='spherical' , in which case it controls if 'hadronic' coordinates (pT,y,phi,[m]) are expected versus 'cartesian' coordinates (E,px,py,pz) . return_flow : bool Whether or not to return the flow matrix describing the optimal transport found during the computation of the EMD. Note that since the second term in Eq. 1 is implemented by including an additional particle in the event with lesser total pT, this will be reflected in the flow matrix. gdim : int The dimension of the ground metric space. Useful for restricting which dimensions are considered part of the ground space. Can be larger than the number of dimensions present in the events (in which case all dimensions will be included). If None , has no effect. mask : bool If True , ignores particles farther than R away from the origin. n_iter_max : int Maximum number of iterations for solving the optimal transport problem. periodic_phi : bool Whether to expect (and therefore properly handle) periodicity in the coordinate corresponding to the azimuthal angle $\\phi$. Should typically be True for event-level applications but can be set to False (which is slightly faster) for jet applications where all $\\phi$ differences are less than or equal to $\\pi$. phi_col : int The index of the column of $\\phi$ values in the event array. empty_policy : float or 'error' Controls behavior if an empty event is passed in. When set to 'error' , a ValueError is raised if an empty event is encountered. If set to a float, that value is returned is returned instead on an empty event. Returns float The EMD value. [ numpy.ndarray ], optional The flow matrix found while solving for the EMD. The (i,j) th entry is the amount of pT that flows between particle i in ev0 and particle j in ev1 . emds_pot energyflow.emd.emds_pot(X0, X1=None, R=1.0, norm=False, beta=1.0, measure='euclidean', coords='hadronic', gdim=None, mask=False, n_iter_max=100000, periodic_phi=False, phi_col=2, empty_policy='error', n_jobs=None, verbose=0, print_every=10**6) Compute the EMDs between collections of events. This can be used to compute EMDs between all pairs of events in a set or between events in two different sets. Arguments X0 : list Iterable collection of events. Each event is assumed to be an (M,1+gdim) array of particles, where M is the multiplicity and gdim is the dimension of the ground space in which to compute euclidean distances between particles (specified by the gdim keyword argument). The zeroth column is assumed to be the energies (or equivalently, the transverse momenta) of the particles. For typical hadron collider jet applications, each particle will be of the form (pT,y,phi) where y is the rapidity and phi is the azimuthal angle. X1 : list or None Iterable collection of events in the same format as X0 , or None . If the latter, the pairwise distances between events in X0 will be computed and the returned matrix will be symmetric. R : float The R parameter in the EMD definition that controls the relative importance of the two terms. Must be greater than or equal to half of the maximum ground distance in the space in order for the EMD to be a valid metric satisfying the triangle inequality. norm : bool Whether or not to normalize the pT values of the events prior to computing the EMD. beta : float The angular weighting exponent. The internal pairwsie distance matrix is raised to this power prior to solving the optimal transport problem. measure : str Controls which metric is used to calculate the ground distances between particles. 'euclidean' uses the euclidean metric in however many dimensions are provided and specified by gdim . 'spherical' uses the opening angle between particles on the sphere (note that this is not fully tested and should be used cautiously). coords : str Only has an effect if measure='spherical' , in which case it controls if 'hadronic' coordinates (pT,y,phi,[m]) are expected versus 'cartesian' coordinates (E,px,py,pz) . gdim : int The dimension of the ground metric space. Useful for restricting which dimensions are considered part of the ground space. Can be larger than the number of dimensions present in the events (in which case all dimensions will be included). If None , has no effect. mask : bool If True , ignores particles farther than R away from the origin. n_iter_max : int Maximum number of iterations for solving the optimal transport problem. periodic_phi : bool Whether to expect (and therefore properly handle) periodicity in the coordinate corresponding to the azimuthal angle $\\phi$. Should typically be True for event-level applications but can be set to False (which is slightly faster) for jet applications where all $\\phi$ differences are less than or equal to $\\pi$. phi_col : int The index of the column of $\\phi$ values in the event array. empty_policy : float or 'error' Controls behavior if an empty event is passed in. When set to 'error' , a ValueError is raised if an empty event is encountered. If set to a float, that value is returned is returned instead on an empty event. n_jobs : int or None The number of worker processes to use. A value of None will use as many processes as there are CPUs on the machine. Note that for smaller numbers of events, a smaller value of n_jobs can be faster. verbose : int Controls the verbosity level. A value greater than 0 will print the progress of the computation at intervals specified by print_every . print_every : int The number of computations to do in between printing the progress. Even if the verbosity level is zero, this still plays a role in determining when the worker processes report the results back to the main process. Returns numpy.ndarray The EMD values as a two-dimensional array. If X1 was None , then the shape will be (len(X0), len(X0)) and the array will be symmetric, otherwise it will have shape (len(X0), len(X1)) .","title":"EMD"},{"location":"docs/emd/#energy-movers-distance","text":"The Energy Mover's Distance (EMD), also known as the Earth Mover's Distance, is a metric between particle collider events introduced in 1902.02346 . This submodule contains convenient functions for computing EMDs between individual events and collections of events. The core of the computation is handled by either the Wasserstein library or the Python Optimal Transport (POT) library, one of which must be installed in order to use this submodule. From Eqs. (1.2) and (1.3) in 2004.04159 , the EMD between two events is the minimum ''work'' required to rearrange one event $\\mathcal E$ into the other $\\mathcal E'$ by movements of energy $f_{ij}$ from particle $i$ in one event to particle $j$ in the other: \\text{EMD}_{\\beta,R}(\\mathcal E,\\mathcal E^\\prime)=\\min_{\\{f_{ij}\\ge0\\}}\\sum_{i=1}^M\\sum_{j=1}^{M'}f_{ij}\\left(\\frac{ \\theta_{ij}}{R}\\right)^\\beta + \\left|\\sum_{i=1}^ME_i-\\sum_{j=1}^{M'}E^\\prime_j \\right|,\\\\\\sum_{j=1}^{M'}f_{ij}\\le E_i, \\quad \\sum_{i=1}^Mf_{ij}\\le E^\\prime_j, \\quad\\sum_{i=1}^M\\sum_{j=1}^{M'}f_{ij}=E_\\text{min}, where $E_i,E^\\prime_j$ are the energies of the particles in the two events, $\\theta_{ij}$ is an angular distance between particles, and $E_\\text{min}=\\min\\left(\\sum_{i=1}^ME_i,\\,\\sum_{j=1}^{M'}E^\\prime_j\\right)$ is the smaller of the two total energies. In a hadronic context, transverse momenta are used instead of energies.","title":"Energy Mover's Distance"},{"location":"docs/emd/#emd","text":"energyflow.emd.emd(*args, **kwargs) Computes the EMD between two events. The emd function is set equal to either emd_wasserstein or emd_pot , with the former preferred unless the Wasserstein library is not available.","title":"emd"},{"location":"docs/emd/#emds","text":"energyflow.emd.emds(*args, **kwargs) Computes the EMDs between collections of events. The emds function is set equal to either emds_wasserstein or emds_pot , with the former preferred unless the Wasserstein library is not available.","title":"emds"},{"location":"docs/emd/#emd_wasserstein","text":"energyflow.emd.emd_wasserstein(ev0, ev1, dists=None, R=1.0, beta=1.0, norm=False, gdim=2, mask=False, return_flow=False, do_timing=False, n_iter_max=100000, epsilon_large_factor=10000.0, epsilon_small_factor=1.0) Compute the EMD between two events using the Wasserstein library. Arguments ev0 : numpy.ndarray The first event, given as a two-dimensional array. The event is assumed to be an (M,1+gdim) array of particles, where M is the multiplicity and gdim is the dimension of the ground space in which to compute euclidean distances between particles (as specified by the gdim keyword argument). The zeroth column is the weights of the particles, typically their energies or transverse momenta. For typical hadron collider jet applications, each particle will be of the form (pT,y,phi) where y is the rapidity and phi is the azimuthal angle. If dists are provided, then the columns after the zeroth are ignored; alternatively a one-dimensional array consisting of just the particle weights may be passed in this case. ev1 : numpy.ndarray The other event, same format as ev0 . dists : numpy.ndarray A distance matrix between particles in ev0 and ev1 . If None , then the columns of the events after the zeroth are taken to be coordinates and the gdim -dimensional Euclidean distance is used. R : float The R parameter in the EMD definition that controls the relative importance of the two terms. Must be greater than or equal to half of the maximum ground distance in the space in order for the EMD to be a valid metric satisfying the triangle inequality. beta : float The angular weighting exponent. The internal pairwsie distance matrix is raised to this power prior to solving the optimal transport problem. norm : bool Whether or not to normalize the particle weights to sum to one prior to computing the EMD. gdim : int The dimension of the ground metric space. Useful for restricting which dimensions are considered part of the ground space when using the internal euclidean distances between particles. Has no effect if dists are provided. return_flow : bool Whether or not to return the flow matrix describing the optimal transport found during the computation of the EMD. Note that since the second term in Eq. 1 is implemented by including an additional particle in the event with lesser total weight, this will be reflected in the flow matrix. mask : bool If True , masks out particles farther than R away from the origin. Has no effect if dists are provided. n_iter_max : int Maximum number of iterations for solving the optimal transport problem. epsilon_large_factor : float Controls some tolerances in the optimal transport solver. This value is multiplied by the floating points epsilon (around 1e-16 for 64-bit floats) to determine the actual tolerance. epsilon_small_factor : float Analogou to epsilon_large_factor but used where the numerical tolerance can be stricter. Returns float The EMD value. [ numpy.ndarray ], optional The flow matrix found while solving for the EMD. The (i,j) th entry is the amount of pT that flows between particle i in ev0 and particle j in ev1 .","title":"emd_wasserstein"},{"location":"docs/emd/#emds_wasserstein","text":"energyflow.emd.emds_wasserstein(events0, events1=None, R=1.0, beta=1.0, norm=False, gdim=2, mask=False, external_emd_handler=None, n_jobs=-1, print_every=0, verbose=0, throw_on_error=True, n_iter_max=100000, epsilon_large_factor=10000.0, epsilon_small_factor=1.0) Compute the EMDs between collections of events. This can be used to compute EMDs between all pairs of events in a set or between events in two different sets. Arguments events0 : list Iterable collection of events. Each event is assumed to be an (M,1+gdim) array of particles, where M is the multiplicity and gdim is the dimension of the ground space in which to compute euclidean distances between particles (as specified by the gdim keyword argument). The zeroth column is the weights of the particles, typically their energies or transverse momenta. For typical hadron collider jet applications, each particle will be of the form (pT,y,phi) where y is the rapidity and phi is the azimuthal angle. If dists are provided, then the columns after the zeroth are ignored; alternatively a one-dimensional array consisting of just the particle weights may be passed in this case. events1 : list or None Iterable collection of events in the same format as events0 , or None . If the latter, the pairwise distances between events in events0 will be computed and the returned matrix will be symmetric. R : float The R parameter in the EMD definition that controls the relative importance of the two terms. Must be greater than or equal to half of the maximum ground distance in the space in order for the EMD to be a valid metric satisfying the triangle inequality. norm : bool Whether or not to normalize the particle weights to sum to one prior to computing the EMD. beta : float The angular weighting exponent. The internal pairwsie distance matrix is raised to this power prior to solving the optimal transport problem. gdim : int The dimension of the ground metric space. Useful for restricting which dimensions are considered part of the ground space when using the internal euclidean distances between particles. mask : bool If True , ignores particles farther than R away from the origin. external_emd_handler : wasserstein.ExternalEMDHandler An instance of an external EMD handler from the wasserstein module, e.g. CorrelationDimension . n_jobs : int or None The number of cpu cores to use. A value of None or -1 will use as many threads as there are CPUs on the machine. print_every : int The number of computations to do in between printing the progress. Even if the verbosity level is zero, this still plays a role in determining when the worker threads report the results back to the main thread and check for interrupt signals. verbose : int Controls the verbosity level. A value greater than 0 will print the progress of the computation at intervals specified by print_every . throw_on_error : bool Whether or not to raise an exception when an issue is encountered. Can be useful when debugging. n_iter_max : int Maximum number of iterations for solving the optimal transport problem. epsilon_large_factor : float Controls some tolerances in the optimal transport solver. This value is multiplied by the floating points epsilon (around 1e-16 for 64-bit floats) to determine the actual tolerance. epsilon_small_factor : float Analogou to epsilon_large_factor but used where the numerical tolerance can be stricter. Returns numpy.ndarray The EMD values as a two-dimensional array, except if an external EMD handler was provided, in which case no value is returned. If events1 was None , then the shape will be (len(events0), len(events0)) and the array will be symmetric, otherwise it will have shape (len(events0), len(events1)) .","title":"emds_wasserstein"},{"location":"docs/emd/#emd_pot","text":"energyflow.emd.emd_pot(ev0, ev1, R=1.0, norm=False, beta=1.0, measure='euclidean', coords='hadronic', return_flow=False, gdim=None, mask=False, n_iter_max=100000, periodic_phi=False, phi_col=2, empty_policy='error') Compute the EMD between two events using the Python Optimal Transport library. Arguments ev0 : numpy.ndarray The first event, given as a two-dimensional array. The event is assumed to be an (M,1+gdim) array of particles, where M is the multiplicity and gdim is the dimension of the ground space in which to compute euclidean distances between particles (as specified by the gdim keyword argument. The zeroth column is assumed to be the energies (or equivalently, the transverse momenta) of the particles. For typical hadron collider jet applications, each particle will be of the form (pT,y,phi) where y is the rapidity and phi is the azimuthal angle. ev1 : numpy.ndarray The other event, same format as ev0 . R : float The R parameter in the EMD definition that controls the relative importance of the two terms. Must be greater than or equal to half of the maximum ground distance in the space in order for the EMD to be a valid metric satisfying the triangle inequality. beta : float The angular weighting exponent. The internal pairwsie distance matrix is raised to this power prior to solving the optimal transport problem. norm : bool Whether or not to normalize the pT values of the events prior to computing the EMD. measure : str Controls which metric is used to calculate the ground distances between particles. 'euclidean' uses the euclidean metric in however many dimensions are provided and specified by gdim . 'spherical' uses the opening angle between particles on the sphere (note that this is not fully tested and should be used cautiously). coords : str Only has an effect if measure='spherical' , in which case it controls if 'hadronic' coordinates (pT,y,phi,[m]) are expected versus 'cartesian' coordinates (E,px,py,pz) . return_flow : bool Whether or not to return the flow matrix describing the optimal transport found during the computation of the EMD. Note that since the second term in Eq. 1 is implemented by including an additional particle in the event with lesser total pT, this will be reflected in the flow matrix. gdim : int The dimension of the ground metric space. Useful for restricting which dimensions are considered part of the ground space. Can be larger than the number of dimensions present in the events (in which case all dimensions will be included). If None , has no effect. mask : bool If True , ignores particles farther than R away from the origin. n_iter_max : int Maximum number of iterations for solving the optimal transport problem. periodic_phi : bool Whether to expect (and therefore properly handle) periodicity in the coordinate corresponding to the azimuthal angle $\\phi$. Should typically be True for event-level applications but can be set to False (which is slightly faster) for jet applications where all $\\phi$ differences are less than or equal to $\\pi$. phi_col : int The index of the column of $\\phi$ values in the event array. empty_policy : float or 'error' Controls behavior if an empty event is passed in. When set to 'error' , a ValueError is raised if an empty event is encountered. If set to a float, that value is returned is returned instead on an empty event. Returns float The EMD value. [ numpy.ndarray ], optional The flow matrix found while solving for the EMD. The (i,j) th entry is the amount of pT that flows between particle i in ev0 and particle j in ev1 .","title":"emd_pot"},{"location":"docs/emd/#emds_pot","text":"energyflow.emd.emds_pot(X0, X1=None, R=1.0, norm=False, beta=1.0, measure='euclidean', coords='hadronic', gdim=None, mask=False, n_iter_max=100000, periodic_phi=False, phi_col=2, empty_policy='error', n_jobs=None, verbose=0, print_every=10**6) Compute the EMDs between collections of events. This can be used to compute EMDs between all pairs of events in a set or between events in two different sets. Arguments X0 : list Iterable collection of events. Each event is assumed to be an (M,1+gdim) array of particles, where M is the multiplicity and gdim is the dimension of the ground space in which to compute euclidean distances between particles (specified by the gdim keyword argument). The zeroth column is assumed to be the energies (or equivalently, the transverse momenta) of the particles. For typical hadron collider jet applications, each particle will be of the form (pT,y,phi) where y is the rapidity and phi is the azimuthal angle. X1 : list or None Iterable collection of events in the same format as X0 , or None . If the latter, the pairwise distances between events in X0 will be computed and the returned matrix will be symmetric. R : float The R parameter in the EMD definition that controls the relative importance of the two terms. Must be greater than or equal to half of the maximum ground distance in the space in order for the EMD to be a valid metric satisfying the triangle inequality. norm : bool Whether or not to normalize the pT values of the events prior to computing the EMD. beta : float The angular weighting exponent. The internal pairwsie distance matrix is raised to this power prior to solving the optimal transport problem. measure : str Controls which metric is used to calculate the ground distances between particles. 'euclidean' uses the euclidean metric in however many dimensions are provided and specified by gdim . 'spherical' uses the opening angle between particles on the sphere (note that this is not fully tested and should be used cautiously). coords : str Only has an effect if measure='spherical' , in which case it controls if 'hadronic' coordinates (pT,y,phi,[m]) are expected versus 'cartesian' coordinates (E,px,py,pz) . gdim : int The dimension of the ground metric space. Useful for restricting which dimensions are considered part of the ground space. Can be larger than the number of dimensions present in the events (in which case all dimensions will be included). If None , has no effect. mask : bool If True , ignores particles farther than R away from the origin. n_iter_max : int Maximum number of iterations for solving the optimal transport problem. periodic_phi : bool Whether to expect (and therefore properly handle) periodicity in the coordinate corresponding to the azimuthal angle $\\phi$. Should typically be True for event-level applications but can be set to False (which is slightly faster) for jet applications where all $\\phi$ differences are less than or equal to $\\pi$. phi_col : int The index of the column of $\\phi$ values in the event array. empty_policy : float or 'error' Controls behavior if an empty event is passed in. When set to 'error' , a ValueError is raised if an empty event is encountered. If set to a float, that value is returned is returned instead on an empty event. n_jobs : int or None The number of worker processes to use. A value of None will use as many processes as there are CPUs on the machine. Note that for smaller numbers of events, a smaller value of n_jobs can be faster. verbose : int Controls the verbosity level. A value greater than 0 will print the progress of the computation at intervals specified by print_every . print_every : int The number of computations to do in between printing the progress. Even if the verbosity level is zero, this still plays a role in determining when the worker processes report the results back to the main process. Returns numpy.ndarray The EMD values as a two-dimensional array. If X1 was None , then the shape will be (len(X0), len(X0)) and the array will be symmetric, otherwise it will have shape (len(X0), len(X1)) .","title":"emds_pot"},{"location":"docs/emds/","text":"","title":"PairwiseEMD"}]}