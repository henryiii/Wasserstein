{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Wasserstein Features The Wasserstein package computes Wasserstein distances and related quantities efficiently. It contains an efficient implementation of the network simplex algorithm originally from the LEMON graph library , modified by Nicolas Boneel , modified by the authors of the Python Optimal Transport (POT) library, and further modified in this package by Patrick Komiske. The main code is written in C++ with a Python wrapper provided via SWIG . The following classes contain the main functionalities of Wasserstein: EMD : Computes the Wasserstein distance between two distributions, including a possible penalty term. Can use either the builtin Euclidean ground distance (with the possibility of raising these to a power beta ) or a custom ground distance between distributions. PairwiseEMD : Computes pairs of Wasserstein distances between collections of distributions. Multi-threading support is provided via OMP. CorrelationDimension : The correlation dimension is a type of fractal dimension that estimates dimensionality of the underlying data manifold on which the distributions live. It has been applied to CMS Open Data . The current version is 0.3.1 . Changes are summarized in the Release Notes . Using the most up-to-date version is recommended. As of version 0.2.0 , tests have been written covering the majority of the code. The source code can be found on GitHub . References [1] N. Bonneel, M. van de Panne, S. Paris, W. Heidrich, Displacement interpolation using Lagrangian mass transport , ACM Trans. Graph. 30 (2011). [2] P. T. Komiske, E. M. Metodiev, and J. Thaler, The Metric Space of Collider Events , Phys. Rev. Lett. 123 (2019) 041801 [ 1902.02346 ]. [3] P. T. Komiske, E. M. Metodiev, and J. Thaler, The Hidden Geometry of Particle Collisions , JHEP 07 (2020) 006 [ 2004.04159 ]. Copyright Wasserstein is licensed under the GNU Puplic License v3 . See the LICENSE for detailed copyright information.","title":"Home"},{"location":"#welcome-to-wasserstein","text":"","title":"Welcome to Wasserstein"},{"location":"#features","text":"The Wasserstein package computes Wasserstein distances and related quantities efficiently. It contains an efficient implementation of the network simplex algorithm originally from the LEMON graph library , modified by Nicolas Boneel , modified by the authors of the Python Optimal Transport (POT) library, and further modified in this package by Patrick Komiske. The main code is written in C++ with a Python wrapper provided via SWIG . The following classes contain the main functionalities of Wasserstein: EMD : Computes the Wasserstein distance between two distributions, including a possible penalty term. Can use either the builtin Euclidean ground distance (with the possibility of raising these to a power beta ) or a custom ground distance between distributions. PairwiseEMD : Computes pairs of Wasserstein distances between collections of distributions. Multi-threading support is provided via OMP. CorrelationDimension : The correlation dimension is a type of fractal dimension that estimates dimensionality of the underlying data manifold on which the distributions live. It has been applied to CMS Open Data . The current version is 0.3.1 . Changes are summarized in the Release Notes . Using the most up-to-date version is recommended. As of version 0.2.0 , tests have been written covering the majority of the code. The source code can be found on GitHub .","title":"Features"},{"location":"#references","text":"[1] N. Bonneel, M. van de Panne, S. Paris, W. Heidrich, Displacement interpolation using Lagrangian mass transport , ACM Trans. Graph. 30 (2011). [2] P. T. Komiske, E. M. Metodiev, and J. Thaler, The Metric Space of Collider Events , Phys. Rev. Lett. 123 (2019) 041801 [ 1902.02346 ]. [3] P. T. Komiske, E. M. Metodiev, and J. Thaler, The Hidden Geometry of Particle Collisions , JHEP 07 (2020) 006 [ 2004.04159 ].","title":"References"},{"location":"#copyright","text":"Wasserstein is licensed under the GNU Puplic License v3 . See the LICENSE for detailed copyright information.","title":"Copyright"},{"location":"demos/","text":"Interactive Demos The following Jupyter notebook demo is available on GitHub. Binder provides an awesome platform for running it durectly in your browser without installing anything whatsoever. For C++ usage, check out the Examples . Wasserstein Demo The Wasserstein Demo provides an introduction to using the Wasserstein package to compute Wasserstein/distances. View or download the notebook from GitHub","title":"Python Demos"},{"location":"demos/#interactive-demos","text":"The following Jupyter notebook demo is available on GitHub. Binder provides an awesome platform for running it durectly in your browser without installing anything whatsoever. For C++ usage, check out the Examples .","title":"Interactive Demos"},{"location":"demos/#wasserstein-demo","text":"The Wasserstein Demo provides an introduction to using the Wasserstein package to compute Wasserstein/distances. View or download the notebook from GitHub","title":"Wasserstein Demo"},{"location":"examples/","text":"Coming soon!","title":"C++ Examples"},{"location":"faqs/","text":"Frequently Asked EnergyFlow Questions Why should I use Wasserstein instead of the Python Optimal Transport (POT) library? How do I cite the Wasserstein package? Where can I get the code? How do I report an issue or a bug? Why should I use Wasserstein instead of the Python Optimal Transport (POT) library? POT offers EMD functionality based on the same algorithm as Wasserstein. You'll find that Wasserstein is faster (up to 2x) for small problems (around 100 particles) due to the more efficient way in which we interface with NumPy. Also, Wasserstein offers greater numerical flexibility, with the ability to control certain floating point epsilons that POT hard codes and can cause failure (especially on macOS, we have found). And then there is the C++ interface that Wasserstein exposes in case you work in that language. How do I cite the Wasserstein package? Please cite the relevant papers if they or this package help your research. Here are the BibTeX entries to use: @article { 10.1145 / 2070781.2024192 , author = \"Bonneel, Nicolas and van de Panne, Michiel and Paris, Sylvain and Heidrich, Wolfgang\" , title = \"{Displacement Interpolation Using Lagrangian Mass Transport}\" , year = \"2011\" , issue_date = \"December 2011\" , publisher = \"Association for Computing Machinery\" , address = \"New York, NY, USA\" , volume = \"30\" , number = \"6\" , issn = \"0730-0301\" , url = \"https://doi.org/10.1145/2070781.2024192\" , doi = \"10.1145/2070781.2024192\" , journal = \"ACM Trans. Graph.\" , month = \"dec\" , pages = \"1\u201312\" , numpages = \"12\" } @article { Komiske : 2019 fks , author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\" , title = \"{Metric Space of Collider Events}\" , eprint = \"1902.02346\" , archivePrefix = \"arXiv\" , primaryClass = \"hep-ph\" , reportNumber = \"MIT-CTP 5102\" , doi = \"10.1103/PhysRevLett.123.041801\" , journal = \"Phys. Rev. Lett.\" , volume = \"123\" , number = \"4\" , pages = \"041801\" , year = \"2019\" } @article { Komiske : 2020 qhg , author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\" , title = \"{The Hidden Geometry of Particle Collisions}\" , eprint = \"2004.04159\" , archivePrefix = \"arXiv\" , primaryClass = \"hep-ph\" , reportNumber = \"MIT-CTP 5185\" , doi = \"10.1007/JHEP07(2020)006\" , journal = \"JHEP\" , volume = \"07\" , pages = \"006\" , year = \"2020\" } Where can I get the code? The code is open source and hosted on GitHub . How do I report an issue? Please report any issues you encounter by creating a GitHub Issue .","title":"FAQs"},{"location":"faqs/#frequently-asked-energyflow-questions","text":"Why should I use Wasserstein instead of the Python Optimal Transport (POT) library? How do I cite the Wasserstein package? Where can I get the code? How do I report an issue or a bug?","title":"Frequently Asked EnergyFlow Questions"},{"location":"faqs/#why-should-i-use-wasserstein-instead-of-the-python-optimal-transport-pot-library","text":"POT offers EMD functionality based on the same algorithm as Wasserstein. You'll find that Wasserstein is faster (up to 2x) for small problems (around 100 particles) due to the more efficient way in which we interface with NumPy. Also, Wasserstein offers greater numerical flexibility, with the ability to control certain floating point epsilons that POT hard codes and can cause failure (especially on macOS, we have found). And then there is the C++ interface that Wasserstein exposes in case you work in that language.","title":"Why should I use Wasserstein instead of the Python Optimal Transport (POT) library?"},{"location":"faqs/#how-do-i-cite-the-wasserstein-package","text":"Please cite the relevant papers if they or this package help your research. Here are the BibTeX entries to use: @article { 10.1145 / 2070781.2024192 , author = \"Bonneel, Nicolas and van de Panne, Michiel and Paris, Sylvain and Heidrich, Wolfgang\" , title = \"{Displacement Interpolation Using Lagrangian Mass Transport}\" , year = \"2011\" , issue_date = \"December 2011\" , publisher = \"Association for Computing Machinery\" , address = \"New York, NY, USA\" , volume = \"30\" , number = \"6\" , issn = \"0730-0301\" , url = \"https://doi.org/10.1145/2070781.2024192\" , doi = \"10.1145/2070781.2024192\" , journal = \"ACM Trans. Graph.\" , month = \"dec\" , pages = \"1\u201312\" , numpages = \"12\" } @article { Komiske : 2019 fks , author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\" , title = \"{Metric Space of Collider Events}\" , eprint = \"1902.02346\" , archivePrefix = \"arXiv\" , primaryClass = \"hep-ph\" , reportNumber = \"MIT-CTP 5102\" , doi = \"10.1103/PhysRevLett.123.041801\" , journal = \"Phys. Rev. Lett.\" , volume = \"123\" , number = \"4\" , pages = \"041801\" , year = \"2019\" } @article { Komiske : 2020 qhg , author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\" , title = \"{The Hidden Geometry of Particle Collisions}\" , eprint = \"2004.04159\" , archivePrefix = \"arXiv\" , primaryClass = \"hep-ph\" , reportNumber = \"MIT-CTP 5185\" , doi = \"10.1007/JHEP07(2020)006\" , journal = \"JHEP\" , volume = \"07\" , pages = \"006\" , year = \"2020\" }","title":"How do I cite the Wasserstein package?"},{"location":"faqs/#where-can-i-get-the-code","text":"The code is open source and hosted on GitHub .","title":"Where can I get the code?"},{"location":"faqs/#how-do-i-report-an-issue","text":"Please report any issues you encounter by creating a GitHub Issue .","title":"How do I report an issue?"},{"location":"installation/","text":"Installation The Wasserstein package can be used as a header-only C++ template library or as a Python package that wraps the C++ code. Python Install via pip Precompiled Python wheels are available for Linux, maxOS, and Windows via PyPI. The only strict dependency is NumPy, though Wurlitzer is also installed in order to redirect standard output into Jupyter notebooks in the demos. Simply run the following in a terminal to install Wasserstein: pip3 install wasserstein Install from Python source The only reason to bother with the source code when using Wasserstein in Python is if one wants to develop some feature in the package. The Wasserstein source code can be obtained from GitHub . Running python3 setup.py swig (which requires the swig binary to be available on the path) will regenerate the Python wrapper code. Running python3 setup.py build_ext --inplace will compile the library, and pip3 install -e . will install a development version pointing to the current directory. C++ The Wasserstein source code can be obtained from GitHub . Since the library is header-only, no compilation is required to install it. The provided install_wasserstein.sh script can be used (on a UNIX-like system, at least) to move the requisite header files to an appropriate location such as /usr/local/include . If your system does not have the Boost libraries (version 1.70.0 or newer is required to access the histogram package) available, set the second argument to true in order to use the provided Boost Histogram header files. Try the following in order to move the Wasserstein header files to an installed location, in this case /usr/local/include : git clone https://github.com/pkomiske/Wasserstein cd Wasserstein chmod +x install_wasserstein.sh ./install_wasserstein /usr/local false","title":"Installation"},{"location":"installation/#installation","text":"The Wasserstein package can be used as a header-only C++ template library or as a Python package that wraps the C++ code.","title":"Installation"},{"location":"installation/#python","text":"","title":"Python"},{"location":"installation/#install-via-pip","text":"Precompiled Python wheels are available for Linux, maxOS, and Windows via PyPI. The only strict dependency is NumPy, though Wurlitzer is also installed in order to redirect standard output into Jupyter notebooks in the demos. Simply run the following in a terminal to install Wasserstein: pip3 install wasserstein","title":"Install via pip"},{"location":"installation/#install-from-python-source","text":"The only reason to bother with the source code when using Wasserstein in Python is if one wants to develop some feature in the package. The Wasserstein source code can be obtained from GitHub . Running python3 setup.py swig (which requires the swig binary to be available on the path) will regenerate the Python wrapper code. Running python3 setup.py build_ext --inplace will compile the library, and pip3 install -e . will install a development version pointing to the current directory.","title":"Install from Python source"},{"location":"installation/#c","text":"The Wasserstein source code can be obtained from GitHub . Since the library is header-only, no compilation is required to install it. The provided install_wasserstein.sh script can be used (on a UNIX-like system, at least) to move the requisite header files to an appropriate location such as /usr/local/include . If your system does not have the Boost libraries (version 1.70.0 or newer is required to access the histogram package) available, set the second argument to true in order to use the provided Boost Histogram header files. Try the following in order to move the Wasserstein header files to an installed location, in this case /usr/local/include : git clone https://github.com/pkomiske/Wasserstein cd Wasserstein chmod +x install_wasserstein.sh ./install_wasserstein /usr/local false","title":"C++"},{"location":"releases/","text":"Release Notes 0.3.x Migrated to use travis-ci.com. 0.3.1 C++ example added. Documentation updated. Small tweaks to some methods. 0.3.0 Changes to some argument names. First version that EnergyFlow is designed to work with. First version with online documentation. 0.2.x 0.2.0 First public version that should have reliable functionality. Tests written that cover most of the code. 0.1.x Rapid testing and development including getting the Python build system on Travis-CI .","title":"Release Notes"},{"location":"releases/#release-notes","text":"","title":"Release Notes"},{"location":"releases/#03x","text":"Migrated to use travis-ci.com. 0.3.1 C++ example added. Documentation updated. Small tweaks to some methods. 0.3.0 Changes to some argument names. First version that EnergyFlow is designed to work with. First version with online documentation.","title":"0.3.x"},{"location":"releases/#02x","text":"0.2.0 First public version that should have reliable functionality. Tests written that cover most of the code.","title":"0.2.x"},{"location":"releases/#01x","text":"Rapid testing and development including getting the Python build system on Travis-CI .","title":"0.1.x"},{"location":"docs/emd/","text":"EMD The EMD class handles computation of individual Wasserstein distances between pairs of distributions. Adopting language from particle physics, we will call the distributions \"events,\" the discrete entities in the ground space \"particles,\" and the particle weights (probability mass) \"energy\". The optimal transport problem can be specified as: \\text{EMD}_{\\beta,R}(\\mathcal E,\\mathcal E^\\prime)=\\min_{\\{f_{ij}\\ge0\\}}\\sum_{i=1}^M\\sum_{j=1}^{M'}f_{ij}\\left(\\frac{ \\theta_{ij}}{R}\\right)^\\beta + \\left|\\sum_{i=1}^ME_i-\\sum_{j=1}^{M'}E^\\prime_j \\right|, \\text{EMD}_{\\beta,R}(\\mathcal E,\\mathcal E^\\prime)=\\min_{\\{f_{ij}\\ge0\\}}\\sum_{i=1}^M\\sum_{j=1}^{M'}f_{ij}\\left(\\frac{ \\theta_{ij}}{R}\\right)^\\beta + \\left|\\sum_{i=1}^ME_i-\\sum_{j=1}^{M'}E^\\prime_j \\right|, \\sum_{j=1}^{M'}f_{ij}\\le E_i, \\quad \\sum_{i=1}^Mf_{ij}\\le E^\\prime_j, \\quad\\sum_{i=1}^M\\sum_{j=1}^{M'}f_{ij}=E_\\text{min}. \\sum_{j=1}^{M'}f_{ij}\\le E_i, \\quad \\sum_{i=1}^Mf_{ij}\\le E^\\prime_j, \\quad\\sum_{i=1}^M\\sum_{j=1}^{M'}f_{ij}=E_\\text{min}. Python The Python EMD class wraps the templated C++ class of the same name. It is designed to work with numpy arrays efficiently. wasserstein . EMD ( R = 1.0 , beta = 1.0 , norm = False , do_timing = False , n_iter_max = 100000 , epsilon_large_factor = 10000.0 , epsilon_small_factor = 1.0 ) Arguments R : float The R parameter in the EMD definition that controls the relative importance of the two terms. Must be greater than or equal to half of the maximum ground distance in the space in order for the EMD to be a valid metric satisfying the triangle inequality. beta : float The angular weighting exponent. The internal pairwsie distance matrix is raised to this power prior to solving the optimal transport problem. norm : bool Whether or not to normalize the particle weights to sum to one prior to computing the EMD. do_timing : bool Whether or not to keep track of the duration of the underlying computation. n_iter_max : int Maximum number of iterations for solving the optimal transport problem. epsilon_large_factor : float Controls some tolerances in the optimal transport solver. This value is multiplied by the floating points epsilon (around 1e-16 for 64-bit floats) to determine the actual tolerance. epsilon_small_factor : float Analogous to epsilon_large_factor but used where the numerical tolerance can be stricter. Compute Distance _ _call __ __call__ ( weights0 , coords0 , weights1 , coords1 ) or, if external_dists is True , __call__ ( weights0 , weights1 , dists ) Compute the Wasserstein distance between two events using the EMD object. Arguments weights0 : 1d numpy.ndarray The weight values of the first event. weights1 : 1d numpy.ndarray The weight values of the second event. In the first version, the Euclidean ground distance is used where the particle coordinates are specified as: coords0 : 2d numpy.ndarray The Cartesian coordinates of the particles in the first event. If the ground space dimension is d , then it has shape (M0, d) where M0 is the length of weights0 . coords1 : 2d numpy.ndarray The Cartesian coordinates of the particles in the second event. If the ground space dimension is d , then it has shape (M1, d) where M1 is the length of weights1 . In the second version, the ground space distances are provided directly: dists : 2d numpy.ndarray The ground distances between particles in the first and second events. To use the above notation, it has shape (M0, M1) . Returns float The Wasserstein distance between event0 and event1. See also emd() . Access Results These methods access quantities determined during the most recent computation. emd emd () The Wasserstein distance. Returns float The cost of transporting event0 to event1 . dists dists () The ground distances between the particles. Returns numpy.ndarray The ground distance matrix as an array with shape (n0, n1) . flows flows () The optimal flow matrix. Returns numpy.ndarray The flow matrix as an array with shape (n0, n1) . flow flow ( i , j ) Access the flow between particle i in event0 and j in event1 . Note that negative indices are accepted and count from the end, as usual in Python. Arguments i : int Index of particle in event0 . An IndexError is raised if out of range. j : int Index of particle in event1 . An IndexError is raised if out of range. Returns float The amount of flow between the specified particles. status status () The status code of the solver. A non-zero value indicates a problem. See the check_emd_status function for interpretting the code. Returns int Networks simplex status code. Zero indicates success, a non-zero value indicates an error. n0 n0 () Number of entities passed to the network simplex solver for event0 . Returns int The number of particles ultimately used in event0 . This may be one greater than the number of given particles in event0 if norm=False and event0 has less total weight than event1 . n1 n1 () Number of entities passed to the network simplex solver for event1 . Returns int The number of particles ultimately used in event1 . This may be one greater than the number of given particles in event1 if norm=False and event1 has less total weight than event0 . extra extra () Which event, if any, got an extra particle. Returns int Which event, 0 or 1 , got an extra particle, or if neither did, -1 . weightdiff weightdiff () Total weight in event1 minus total weight in event0 . Returns float The internally calculated difference in total weight between event1 and event0 . scale scale () The optimal transport problem is internally rescaled in order to provide more numerically stable computations. The scale is the value that the weights are divided by prior to running the network simplex algorithm. Returns float The internally utilized scaling factor for the weights. duration duration () The duration of the core of the optimal transport calculation via the network simplex algorithm. Returns float The time, in seconds, of the computation. If do_timing was not True for this computation then this value is not meaningful. Get/Set Options These methods can be used to get the current settings of the EMD object or to set new ones. The getter methods are: R() : returns float beta() : returns float norm() : returns bool do_timing : returns bool The setter methods are: set_R(new_R) : accepts float set_beta(new_beta) : accepts float set_norm(new_norm) : accepts bool set_do_timing(new_do_timing) : accepts bool set_network_simplex_params(n_iter_max=100000, epsilon_large_factor=10000.0, epsilon_small_factor=1.0) This method resets all of the underlying network simplex solver's parameters at once. Other Methods description description ( write_preprocessors = True ) Returns a string that describes the EMD object. Printing the EMD object uses this method to describe the object. Arguments write_preprocessors : bool Whether or not to include preprocessors in the description. There are currently no preprocessors included in the Wasserstein package but this may change in the future. Returns string The description of the EMD object. clear clear () Frees some memory in use by the EMD object. This should not normally need to be called by the user. C++ The EMD C++ class is a template class that accepts three parameters: an Event class, a PairwiseDistance class, and a NetworkSimplex class. Each of these should have the same floating-point type ( double , by default) typedef'd to Value , which will be used throughout. template < class Event , class PairwiseDistance , class NetworkSimplex = lemon :: NetworkSimplex <>> emd :: EMD ( Value R = 1 , Value beta = 1 , bool norm = false , bool do_timing = false , bool external_dists = false , unsigned n_iter_max = 100000 , Value epsilon_large_factor = 10000 , Value epsilon_small_factor = 1 ); See the Python class of the same name for the meaning of these arguments. external_dists is a new flag indicating whether or not the internal PairwiseDistance object should be used to obtain ground distances or whether the ground distances will be externally provided (see the ground_dists() method below). Compute Distances There are two methods that can be used to compute an EMD distance between two events, operator() and compute . The difference is that the first is templated to accept \"proto events\" (which may be of type Event , or are something that Event can be constructed from) and also preprocesses the events. The second accepts two already constructed events, does not preprocess them, and does not check that their weights have been setup properly. operator() template < class ProtoEvent0 , class ProtoEvent1 > Value operator ()( const ProtoEvent0 & pev0 , const ProtoEvent1 & pev1 ); This version preprocesses each event to ensure any preprocessors are called and the weights are normalized properly (if norm=true ). Arguments pev0 The first event will be constructed by calling Event(pev0) . pev1 The second event will be constructed by calling Event(pev1) . Returns The Wasserstein distance between the two events. compute Value compute ( const Event & ev0 , const Event & ev1 ); This version computes the distance between the two events as they are, without any preprocessing. Arguments ev0 The first event. ev1 The second event. Returns The Wasserstein distance between the two events. In case external ground distances are to be used, the following methods provide a reference to the vector of distances used by the network simplex object. Note that if norm=false , then one of the events will generically get an extra particle to account for the difference in weights, and the external dists should account for this. The distances are expected to be provided in row-major (C-style) order. std :: vector < Value > & ground_dists (); const std :: vector < Value > & ground_dists () const ; Access Results Many of the methods share the same names as the Python ones . These are: Value emd () const ; std :: vector < Value > dists () const ; std :: vector < Value > flows () const ; Value flow ( long long i , long long j ); emd :: EMDStatus status () const ; size_t n0 () const ; size_t n1 () const ; emd :: ExtraParticle extra () const ; Value weightdiff () const ; Value scale () const ; double duration () const ; EMDStatus and ExtraParticle are enums; see the C++ Utils Get/Set Options These methods can be used to get the current settings of the EMD object or to set new ones. The getter methods are: Value R () const ; Value beta () const ; bool norm () const ; bool do_timing () const ; bool external_dists () const ; const NetworkSimplex & network_simplex () const ; const PairwiseDistance & pairwise_distance () const ; external_dists() indicates whether or not to use the internal PairwiseDistance object or to assume that the ground distances have been externally set. network_simplex() and pairwise_distance() access the underlying objects used to do the heavy lifting of the computation. The setter methods are: void set_R ( Value R ); void set_beta ( Value beta ); void set_norm ( bool norm ); void set_do_timing ( bool do_timing ); void set_external_dists ( bool exdists ); void set_network_simplex_params ( unsigned n_iter_max = 100000 , Value epsilon_large_factor = 10000 , Value epsilon_small_factor = 1 ); Other Methods preprocess template < template < class > class P , typename ... Args > EMD & preprocess ( Args && ... args ) Adds a preprocessor to the internal list. Each event will be preprocessed by the preprocessors in the order they were given. Currently, there is one preprocessor as part of Wasserstein, CenterWeightedCentroid . Since this preprocessor takes no arguments, it can be added as: emd_obj . preprocess < emd :: CenterWeightedCentroid > () In general, any arguments to the preprocessor class are given as arguments to this method. A reference to the EMD object is returned. description std :: string description ( bool write_preprocessors = true ) Returns a string that describes the EMD object. Arguments write_preprocessors Whether or not to include preprocessors in the description. There are currently no preprocessors included in the Wasserstein package but this may change in the future. Returns The description of the EMD object. clear void clear () Frees some memory in use by the EMD object. This should not normally need to be called by the user.","title":"EMD"},{"location":"docs/emd/#emd","text":"The EMD class handles computation of individual Wasserstein distances between pairs of distributions. Adopting language from particle physics, we will call the distributions \"events,\" the discrete entities in the ground space \"particles,\" and the particle weights (probability mass) \"energy\". The optimal transport problem can be specified as: \\text{EMD}_{\\beta,R}(\\mathcal E,\\mathcal E^\\prime)=\\min_{\\{f_{ij}\\ge0\\}}\\sum_{i=1}^M\\sum_{j=1}^{M'}f_{ij}\\left(\\frac{ \\theta_{ij}}{R}\\right)^\\beta + \\left|\\sum_{i=1}^ME_i-\\sum_{j=1}^{M'}E^\\prime_j \\right|, \\text{EMD}_{\\beta,R}(\\mathcal E,\\mathcal E^\\prime)=\\min_{\\{f_{ij}\\ge0\\}}\\sum_{i=1}^M\\sum_{j=1}^{M'}f_{ij}\\left(\\frac{ \\theta_{ij}}{R}\\right)^\\beta + \\left|\\sum_{i=1}^ME_i-\\sum_{j=1}^{M'}E^\\prime_j \\right|, \\sum_{j=1}^{M'}f_{ij}\\le E_i, \\quad \\sum_{i=1}^Mf_{ij}\\le E^\\prime_j, \\quad\\sum_{i=1}^M\\sum_{j=1}^{M'}f_{ij}=E_\\text{min}. \\sum_{j=1}^{M'}f_{ij}\\le E_i, \\quad \\sum_{i=1}^Mf_{ij}\\le E^\\prime_j, \\quad\\sum_{i=1}^M\\sum_{j=1}^{M'}f_{ij}=E_\\text{min}.","title":"EMD"},{"location":"docs/emd/#python","text":"The Python EMD class wraps the templated C++ class of the same name. It is designed to work with numpy arrays efficiently. wasserstein . EMD ( R = 1.0 , beta = 1.0 , norm = False , do_timing = False , n_iter_max = 100000 , epsilon_large_factor = 10000.0 , epsilon_small_factor = 1.0 ) Arguments R : float The R parameter in the EMD definition that controls the relative importance of the two terms. Must be greater than or equal to half of the maximum ground distance in the space in order for the EMD to be a valid metric satisfying the triangle inequality. beta : float The angular weighting exponent. The internal pairwsie distance matrix is raised to this power prior to solving the optimal transport problem. norm : bool Whether or not to normalize the particle weights to sum to one prior to computing the EMD. do_timing : bool Whether or not to keep track of the duration of the underlying computation. n_iter_max : int Maximum number of iterations for solving the optimal transport problem. epsilon_large_factor : float Controls some tolerances in the optimal transport solver. This value is multiplied by the floating points epsilon (around 1e-16 for 64-bit floats) to determine the actual tolerance. epsilon_small_factor : float Analogous to epsilon_large_factor but used where the numerical tolerance can be stricter.","title":"Python"},{"location":"docs/emd/#compute-distance","text":"","title":"Compute Distance"},{"location":"docs/emd/#__call__","text":"__call__ ( weights0 , coords0 , weights1 , coords1 ) or, if external_dists is True , __call__ ( weights0 , weights1 , dists ) Compute the Wasserstein distance between two events using the EMD object. Arguments weights0 : 1d numpy.ndarray The weight values of the first event. weights1 : 1d numpy.ndarray The weight values of the second event. In the first version, the Euclidean ground distance is used where the particle coordinates are specified as: coords0 : 2d numpy.ndarray The Cartesian coordinates of the particles in the first event. If the ground space dimension is d , then it has shape (M0, d) where M0 is the length of weights0 . coords1 : 2d numpy.ndarray The Cartesian coordinates of the particles in the second event. If the ground space dimension is d , then it has shape (M1, d) where M1 is the length of weights1 . In the second version, the ground space distances are provided directly: dists : 2d numpy.ndarray The ground distances between particles in the first and second events. To use the above notation, it has shape (M0, M1) . Returns float The Wasserstein distance between event0 and event1. See also emd() .","title":"__call__"},{"location":"docs/emd/#access-results","text":"These methods access quantities determined during the most recent computation.","title":"Access Results"},{"location":"docs/emd/#emd_1","text":"emd () The Wasserstein distance. Returns float The cost of transporting event0 to event1 .","title":"emd"},{"location":"docs/emd/#dists","text":"dists () The ground distances between the particles. Returns numpy.ndarray The ground distance matrix as an array with shape (n0, n1) .","title":"dists"},{"location":"docs/emd/#flows","text":"flows () The optimal flow matrix. Returns numpy.ndarray The flow matrix as an array with shape (n0, n1) .","title":"flows"},{"location":"docs/emd/#flow","text":"flow ( i , j ) Access the flow between particle i in event0 and j in event1 . Note that negative indices are accepted and count from the end, as usual in Python. Arguments i : int Index of particle in event0 . An IndexError is raised if out of range. j : int Index of particle in event1 . An IndexError is raised if out of range. Returns float The amount of flow between the specified particles.","title":"flow"},{"location":"docs/emd/#status","text":"status () The status code of the solver. A non-zero value indicates a problem. See the check_emd_status function for interpretting the code. Returns int Networks simplex status code. Zero indicates success, a non-zero value indicates an error.","title":"status"},{"location":"docs/emd/#n0","text":"n0 () Number of entities passed to the network simplex solver for event0 . Returns int The number of particles ultimately used in event0 . This may be one greater than the number of given particles in event0 if norm=False and event0 has less total weight than event1 .","title":"n0"},{"location":"docs/emd/#n1","text":"n1 () Number of entities passed to the network simplex solver for event1 . Returns int The number of particles ultimately used in event1 . This may be one greater than the number of given particles in event1 if norm=False and event1 has less total weight than event0 .","title":"n1"},{"location":"docs/emd/#extra","text":"extra () Which event, if any, got an extra particle. Returns int Which event, 0 or 1 , got an extra particle, or if neither did, -1 .","title":"extra"},{"location":"docs/emd/#weightdiff","text":"weightdiff () Total weight in event1 minus total weight in event0 . Returns float The internally calculated difference in total weight between event1 and event0 .","title":"weightdiff"},{"location":"docs/emd/#scale","text":"scale () The optimal transport problem is internally rescaled in order to provide more numerically stable computations. The scale is the value that the weights are divided by prior to running the network simplex algorithm. Returns float The internally utilized scaling factor for the weights.","title":"scale"},{"location":"docs/emd/#duration","text":"duration () The duration of the core of the optimal transport calculation via the network simplex algorithm. Returns float The time, in seconds, of the computation. If do_timing was not True for this computation then this value is not meaningful.","title":"duration"},{"location":"docs/emd/#getset-options","text":"These methods can be used to get the current settings of the EMD object or to set new ones. The getter methods are: R() : returns float beta() : returns float norm() : returns bool do_timing : returns bool The setter methods are: set_R(new_R) : accepts float set_beta(new_beta) : accepts float set_norm(new_norm) : accepts bool set_do_timing(new_do_timing) : accepts bool set_network_simplex_params(n_iter_max=100000, epsilon_large_factor=10000.0, epsilon_small_factor=1.0) This method resets all of the underlying network simplex solver's parameters at once.","title":"Get/Set Options"},{"location":"docs/emd/#other-methods","text":"","title":"Other Methods"},{"location":"docs/emd/#description","text":"description ( write_preprocessors = True ) Returns a string that describes the EMD object. Printing the EMD object uses this method to describe the object. Arguments write_preprocessors : bool Whether or not to include preprocessors in the description. There are currently no preprocessors included in the Wasserstein package but this may change in the future. Returns string The description of the EMD object.","title":"description"},{"location":"docs/emd/#clear","text":"clear () Frees some memory in use by the EMD object. This should not normally need to be called by the user.","title":"clear"},{"location":"docs/emd/#c","text":"The EMD C++ class is a template class that accepts three parameters: an Event class, a PairwiseDistance class, and a NetworkSimplex class. Each of these should have the same floating-point type ( double , by default) typedef'd to Value , which will be used throughout. template < class Event , class PairwiseDistance , class NetworkSimplex = lemon :: NetworkSimplex <>> emd :: EMD ( Value R = 1 , Value beta = 1 , bool norm = false , bool do_timing = false , bool external_dists = false , unsigned n_iter_max = 100000 , Value epsilon_large_factor = 10000 , Value epsilon_small_factor = 1 ); See the Python class of the same name for the meaning of these arguments. external_dists is a new flag indicating whether or not the internal PairwiseDistance object should be used to obtain ground distances or whether the ground distances will be externally provided (see the ground_dists() method below).","title":"C++"},{"location":"docs/emd/#compute-distances","text":"There are two methods that can be used to compute an EMD distance between two events, operator() and compute . The difference is that the first is templated to accept \"proto events\" (which may be of type Event , or are something that Event can be constructed from) and also preprocesses the events. The second accepts two already constructed events, does not preprocess them, and does not check that their weights have been setup properly.","title":"Compute Distances"},{"location":"docs/emd/#operator","text":"template < class ProtoEvent0 , class ProtoEvent1 > Value operator ()( const ProtoEvent0 & pev0 , const ProtoEvent1 & pev1 ); This version preprocesses each event to ensure any preprocessors are called and the weights are normalized properly (if norm=true ). Arguments pev0 The first event will be constructed by calling Event(pev0) . pev1 The second event will be constructed by calling Event(pev1) . Returns The Wasserstein distance between the two events.","title":"operator()"},{"location":"docs/emd/#compute","text":"Value compute ( const Event & ev0 , const Event & ev1 ); This version computes the distance between the two events as they are, without any preprocessing. Arguments ev0 The first event. ev1 The second event. Returns The Wasserstein distance between the two events. In case external ground distances are to be used, the following methods provide a reference to the vector of distances used by the network simplex object. Note that if norm=false , then one of the events will generically get an extra particle to account for the difference in weights, and the external dists should account for this. The distances are expected to be provided in row-major (C-style) order. std :: vector < Value > & ground_dists (); const std :: vector < Value > & ground_dists () const ;","title":"compute"},{"location":"docs/emd/#access-results_1","text":"Many of the methods share the same names as the Python ones . These are: Value emd () const ; std :: vector < Value > dists () const ; std :: vector < Value > flows () const ; Value flow ( long long i , long long j ); emd :: EMDStatus status () const ; size_t n0 () const ; size_t n1 () const ; emd :: ExtraParticle extra () const ; Value weightdiff () const ; Value scale () const ; double duration () const ; EMDStatus and ExtraParticle are enums; see the C++ Utils","title":"Access Results"},{"location":"docs/emd/#getset-options_1","text":"These methods can be used to get the current settings of the EMD object or to set new ones. The getter methods are: Value R () const ; Value beta () const ; bool norm () const ; bool do_timing () const ; bool external_dists () const ; const NetworkSimplex & network_simplex () const ; const PairwiseDistance & pairwise_distance () const ; external_dists() indicates whether or not to use the internal PairwiseDistance object or to assume that the ground distances have been externally set. network_simplex() and pairwise_distance() access the underlying objects used to do the heavy lifting of the computation. The setter methods are: void set_R ( Value R ); void set_beta ( Value beta ); void set_norm ( bool norm ); void set_do_timing ( bool do_timing ); void set_external_dists ( bool exdists ); void set_network_simplex_params ( unsigned n_iter_max = 100000 , Value epsilon_large_factor = 10000 , Value epsilon_small_factor = 1 );","title":"Get/Set Options"},{"location":"docs/emd/#other-methods_1","text":"","title":"Other Methods"},{"location":"docs/emd/#preprocess","text":"template < template < class > class P , typename ... Args > EMD & preprocess ( Args && ... args ) Adds a preprocessor to the internal list. Each event will be preprocessed by the preprocessors in the order they were given. Currently, there is one preprocessor as part of Wasserstein, CenterWeightedCentroid . Since this preprocessor takes no arguments, it can be added as: emd_obj . preprocess < emd :: CenterWeightedCentroid > () In general, any arguments to the preprocessor class are given as arguments to this method. A reference to the EMD object is returned.","title":"preprocess"},{"location":"docs/emd/#description_1","text":"std :: string description ( bool write_preprocessors = true ) Returns a string that describes the EMD object. Arguments write_preprocessors Whether or not to include preprocessors in the description. There are currently no preprocessors included in the Wasserstein package but this may change in the future. Returns The description of the EMD object.","title":"description"},{"location":"docs/emd/#clear_1","text":"void clear () Frees some memory in use by the EMD object. This should not normally need to be called by the user.","title":"clear"},{"location":"docs/emds/","text":"PairwiseEMD The PairwiseEMD class handles the collective computation of Wasserstein distances between pairs of events. Adopting language from particle physics, we will call the distributions \"events,\" the discrete entities in the ground space \"particles,\" and the particle weights (probability mass) \"energy\". It automatically parallelizes the computations across a specified number of threads for the greatest efficiency. Python The Python EMD class wraps the templated C++ class of the same name. It is designed to work with numpy arrays efficiently. wasserstein . PairwiseEMD ( R = 1.0 , beta = 1.0 , norm = False , num_threads =- 1 , print_every =- 10 , verbose = 1 , store_sym_emds_flattened = True , throw_on_error = False , n_iter_max = 100000 , epsilon_large_factor = 10000.0 , epsilon_small_factor = 1.0 ) Arguments R : float The R parameter in the EMD definition that controls the relative importance of the two terms. Must be greater than or equal to half of the maximum ground distance in the space in order for the EMD to be a valid metric satisfying the triangle inequality. beta : float The angular weighting exponent. The internal pairwsie distance matrix is raised to this power prior to solving the optimal transport problem. norm : bool Whether or not to normalize the particle weights to sum to one prior to computing the EMD. num_threads : int The number of threads to use when executing the computations. A value of -1 uses the maximum number according to omp_get_max_threads() and should be used for the greatest efficiency. print_every : int This controls how the slate of EMD computations is divied up. If positive, it is essentially a batch size - i.e. how many computations to do before printing progress (see verbose ), checking for signals, etc., and then continuing. If negative, it is the approximate total number of times to print progress, etc. A value of 0 is equivalent to -1 . Setting this to a small positive number or a large (in absolute value) negative number tends to be inefficient. verbose : int Controls verbosity of the object. All printing is turned off if equal to 0 . Larger numbers turn on successively more printing. Currently there is only one verbosity level but more may be added. For capturing this output in a Jupyter notebook, run %load_ext wurlitzer prior to starting the computation. store_sym_emds_flattened : bool throw_on_error : bool n_iter_max : int Maximum number of iterations for solving the optimal transport problem. epsilon_large_factor : float Controls some tolerances in the optimal transport solver. This value is multiplied by the floating points epsilon (around 1e-16 for 64-bit floats) to determine the actual tolerance. epsilon_small_factor : float Analogous to epsilon_large_factor but used where the numerical tolerance can be stricter. Compute Distances _ _call __ __call__ ( eventsA , eventsB = None , gdim = None , mask = False ) Compute the Wasserstein distances between all pairs of events using the Euclidean ground distance. If eventsB is None then the computations will be between pairs of events drawn from eventsA , otherwise they are between all pairs of events between eventsA and eventsB . Each event should be a two-dimensional numpy array where the first column is the weights and the remaining columns are the coordinates of the particles in the Euclidean ground space. This method does not return anything; see the Access Results section below. Arguments eventsA : { numpy.ndarray , list } of numpy.ndarray The first dataset of events as a list or numpy object array of events. Each event should be a two-dimensional numpy array where the weights are the first column and the Euclidean coordinates are the remaining columns. eventsB : { numpy.ndarray , list } of numpy.ndarray or None A collection of events with the same structure as eventsA , if not None . This may be None in which case the computations are between all pairs of events from eventsA (effectively, eventsB is set equal to eventsA ). gdim : int or None If None , has no effect. If an integer, then this is the dimension of the ground space and the first gdim columns after the first (which contains the weights) are used as the particle coordinates. Concretely, for an event the weights are event[:,0] and the coordinates are #!python event[:,1:gdim+1] . mask : bool If True , then particles farther than R away from the origin of the ground space will be ignored in the EMD computations, where R is the parameter given to the constructor of the PairwiseEMD object. Access Results These methods access quantities determined during the most recent call to __call__ . emds emds () Matrix of Wasserstein distances as a numpy array. If eventsB was None then this will have shape (nevA, nevA) , otherwise it will have shape (nevA, nevB) . Returns 2d numpy.ndarray Matrix of Wasserstein distances. If eventsB was None then it will be symmetric. emd emd ( i , j ) The Wasserstein distance between event i from eventsA and event j from eventsB (or eventsA if eventsB is None ). Note that negative indices are accepted and count from the end, as usual in Python. Arguments i : int The index of an event from eventsA . An IndexError is raised if it is out of range. j : int The index of an event from eventsB , or eventsA if eventsB was None . An IndexError is raised if it is out of range. Returns float The Wasserstein distance between the specified events. nevA nevA () Returns int The number of events in dataset A. nevB nevB () If eventsB was None , this will be the same as nevA . Returns int The number of events in dataset B. num_emds num_emds () Returns int The number of unique EMD computations carried out. duration duration () Returns float The wall time, in seconds, of the previous computation. errored errored () Whether or not any individual computations had a non-zero return status, indicating an error. Returns bool Whether any errors occurred among the computations. error_messages error_messages () Error messages, if any, that have occurred during the computations. Returns list of str A list of the error messages for anything that went wrong during the computations. An empty list means there were no errors. Get/Set Options These methods can be used to get the current settings of the PairwiseEMD object or to set new ones. The getter methods are: R() : returns float beta() : returns float norm() : returns bool omp_dynamic_chunksize() : returns int The number of EMD computations spooled to each thread at a time. external_handler() : returns bool This will be True if there is an external EMD handler associated with the PairwiseEMD object and False otherwise. The setter methods are: set_R(new_R) : accepts float set_beta(new_beta) : accepts float set_norm(new_norm) : accepts bool set_network_simplex_params(n_iter_max=100000, epsilon_large_factor=10000.0, epsilon_small_factor=1.0) This method resets all of the underlying network simplex solver's parameters at once. set_omp_dynamic_chunksize(new_chunksize) : accepts int Sets the number of EMD evaluations spooled to each thread at a time. set_external_emd_handler set_external_emd_handler ( emd_handler ) Associates this PairwiseEMD object with an ExternalEMDHandler . The results of the EMD computations will not be internally stored but will be passed on to the handler in a thread-safe manner for processing. Arguments emd_handler : ExternalEMDHandler An instance of ExternalEMDHandler that processes EMD values in an online manner. Other Methods description description ( write_preprocessors = True ) Returns a string that describes the PairwiseEMD object. Printing the PairwiseEMD object uses this method to describe the object. Arguments write_preprocessors : bool Whether or not to include preprocessors in the description. There are currently no preprocessors included in the Wasserstein package but this may change in the future. Returns string The description of the PairwiseEMD object. clear clear () Frees some memory in use by the PairwiseEMD object. This should not normally need to be called by the user, except possibly after a larger computation. Note that this also removes any external EMD handler that may be present. C++ The PairwiseEMD C++ class is a template class that accepts a fully-qualified EMD type parameter, from which it obtains information about event types, pairwise distance types, etc. There are two constructors: one that takes many of the same arguments as the EMD class in order to construct them internally and one that accepts a fully built EMD object. template < class EMD > emd :: PairwiseEMD ( Value R = 1 , Value beta = 1 , bool norm = false , int num_threads = -1 , long long print_every = -10 , unsigned verbose = 1 , bool store_sym_emds_flattened = true , bool throw_on_error = false , unsigned n_iter_max = 100000 , Value epsilon_large_factor = 10000 , Value epsilon_small_factor = 1 , std :: ostream & os = std :: cout ); template < class EMD > emd :: PairwiseEMD ( const EMD & emd , int num_threads = -1 , long long print_every = -10 , unsigned verbose = 1 , bool store_sym_emds_flattened = true , bool throw_on_error = false , std :: ostream & os = std :: cout ) See the Python class of the same name for the meaning of these arguments. os is an output stream that will be used for printing if verbose . Compute Distances The operator() and compute methods are overloaded to compute collections of EMD distances between two sets of events in different ways. Each has a one-argument version that computes all EMDs between every pair of events in the provided collection. Each also has a two-argument version that computes all EMDs between pairs of events with one from each set. Just as with the EMD methods of the same name, the operator() methods accept \"proto events\" (which may be of type Event or are something that Event can be constructed from) that will be preprocessed and compute accepts fully-constructed events that will not be preprocessed. operator() template < class ProtoEvent > void operator ()( const std :: vector < ProtoEvent > & proto_events ); template < class ProtoEventA , class ProtoEventB > void operator ()( const std :: vector < ProtoEventA > & proto_eventsA , const std :: vector < ProtoEventB > & proto_eventsB ); This version preprocesses each event to ensure any preprocessors are called and the weights are normalized properly (if norm=true ). Arguments proto_events[A/B] Collection of proto events; the actual events will be obtained by calling Event(proto_event) for each proto_event in the vector. compute void compute ( const std :: vector < Event > & events ); void compute ( const std :: vector < Event > & eventsA , const std :: vector < Event > & eventsB ); This version does not apply any preprocessing. Arguments events[A/B] Collection of fully-constructed events. Access Results Many of the methods share the same names as the Python ones . These are: const std :: vector < Value > & emds ( bool raw = false ); const std :: vector < Event > & events () const ; Value emd ( long long i , long long j ) const ; size_t nevA () const ; size_t nevB () const ; size_t num_emds () const ; double duration () const ; bool errored () const ; const std :: vector < std :: string > & error_messages () const ; The emds method returns a reference to a vector of the EMD results, where the distance matrix has been flattened into a nevA()*nevB() -sized vector in row-major (C-style) order. If only a single set of events was passed and raw=true then the non-symmetrized results of size nevA()*(nevA()-1)/2 are returned. This throws an error if there was an external EMD handler present. The events method returns a const reference to the vector of events that was used for the computations. Get/Set Options These methods can be used to get the current settings of the EMD object or to set new ones. The getter methods are: Value R () const ; Value beta () const ; bool norm () const ; bool external_handler () const ; int omp_dynamic_chunksize () const ; external_dists() indicates whether or not to use the internal PairwiseDistance object or to assume that the ground distances have been externally set. network_simplex() and pairwise_distance() access the underlying objects used to do the heavy lifting of the computation. The setter methods are: void set_R ( Value R ); void set_beta ( Value beta ); void set_norm ( bool norm ); void set_external_emd_handler ( ExternalEMDHandler & handler ); void set_omp_dynamic_chunksize ( int chunksize ); void set_network_simplex_params ( unsigned n_iter_max = 100000 , Value epsilon_large_factor = 10000 , Value epsilon_small_factor = 1 ); See External EMD Handlers for more details. Other Methods preprocess template < template < class > class P , typename ... Args > PairwiseEMD & preprocess ( Args && ... args ) Adds a preprocessor to the internal list. Each event will be preprocessed by the preprocessors in the order they were given. Currently, there is one preprocessor as part of Wasserstein, CenterWeightedCentroid . Since this preprocessor takes no arguments, it can be added as: pairwise_emd_obj . preprocess < emd :: CenterWeightedCentroid > () In general, any arguments to the preprocessor class are given as arguments to this method. A reference to the PairwiseEMD object is returned. description std :: string description () Returns A string that describes the PairwiseEMD object. clear void clear () Frees some memory in use by the PairwiseEMD object. This should not normally need to be called by the user.","title":"PairwiseEMD"},{"location":"docs/emds/#pairwiseemd","text":"The PairwiseEMD class handles the collective computation of Wasserstein distances between pairs of events. Adopting language from particle physics, we will call the distributions \"events,\" the discrete entities in the ground space \"particles,\" and the particle weights (probability mass) \"energy\". It automatically parallelizes the computations across a specified number of threads for the greatest efficiency.","title":"PairwiseEMD"},{"location":"docs/emds/#python","text":"The Python EMD class wraps the templated C++ class of the same name. It is designed to work with numpy arrays efficiently. wasserstein . PairwiseEMD ( R = 1.0 , beta = 1.0 , norm = False , num_threads =- 1 , print_every =- 10 , verbose = 1 , store_sym_emds_flattened = True , throw_on_error = False , n_iter_max = 100000 , epsilon_large_factor = 10000.0 , epsilon_small_factor = 1.0 ) Arguments R : float The R parameter in the EMD definition that controls the relative importance of the two terms. Must be greater than or equal to half of the maximum ground distance in the space in order for the EMD to be a valid metric satisfying the triangle inequality. beta : float The angular weighting exponent. The internal pairwsie distance matrix is raised to this power prior to solving the optimal transport problem. norm : bool Whether or not to normalize the particle weights to sum to one prior to computing the EMD. num_threads : int The number of threads to use when executing the computations. A value of -1 uses the maximum number according to omp_get_max_threads() and should be used for the greatest efficiency. print_every : int This controls how the slate of EMD computations is divied up. If positive, it is essentially a batch size - i.e. how many computations to do before printing progress (see verbose ), checking for signals, etc., and then continuing. If negative, it is the approximate total number of times to print progress, etc. A value of 0 is equivalent to -1 . Setting this to a small positive number or a large (in absolute value) negative number tends to be inefficient. verbose : int Controls verbosity of the object. All printing is turned off if equal to 0 . Larger numbers turn on successively more printing. Currently there is only one verbosity level but more may be added. For capturing this output in a Jupyter notebook, run %load_ext wurlitzer prior to starting the computation. store_sym_emds_flattened : bool throw_on_error : bool n_iter_max : int Maximum number of iterations for solving the optimal transport problem. epsilon_large_factor : float Controls some tolerances in the optimal transport solver. This value is multiplied by the floating points epsilon (around 1e-16 for 64-bit floats) to determine the actual tolerance. epsilon_small_factor : float Analogous to epsilon_large_factor but used where the numerical tolerance can be stricter.","title":"Python"},{"location":"docs/emds/#compute-distances","text":"","title":"Compute Distances"},{"location":"docs/emds/#__call__","text":"__call__ ( eventsA , eventsB = None , gdim = None , mask = False ) Compute the Wasserstein distances between all pairs of events using the Euclidean ground distance. If eventsB is None then the computations will be between pairs of events drawn from eventsA , otherwise they are between all pairs of events between eventsA and eventsB . Each event should be a two-dimensional numpy array where the first column is the weights and the remaining columns are the coordinates of the particles in the Euclidean ground space. This method does not return anything; see the Access Results section below. Arguments eventsA : { numpy.ndarray , list } of numpy.ndarray The first dataset of events as a list or numpy object array of events. Each event should be a two-dimensional numpy array where the weights are the first column and the Euclidean coordinates are the remaining columns. eventsB : { numpy.ndarray , list } of numpy.ndarray or None A collection of events with the same structure as eventsA , if not None . This may be None in which case the computations are between all pairs of events from eventsA (effectively, eventsB is set equal to eventsA ). gdim : int or None If None , has no effect. If an integer, then this is the dimension of the ground space and the first gdim columns after the first (which contains the weights) are used as the particle coordinates. Concretely, for an event the weights are event[:,0] and the coordinates are #!python event[:,1:gdim+1] . mask : bool If True , then particles farther than R away from the origin of the ground space will be ignored in the EMD computations, where R is the parameter given to the constructor of the PairwiseEMD object.","title":"__call__"},{"location":"docs/emds/#access-results","text":"These methods access quantities determined during the most recent call to __call__ .","title":"Access Results"},{"location":"docs/emds/#emds","text":"emds () Matrix of Wasserstein distances as a numpy array. If eventsB was None then this will have shape (nevA, nevA) , otherwise it will have shape (nevA, nevB) . Returns 2d numpy.ndarray Matrix of Wasserstein distances. If eventsB was None then it will be symmetric.","title":"emds"},{"location":"docs/emds/#emd","text":"emd ( i , j ) The Wasserstein distance between event i from eventsA and event j from eventsB (or eventsA if eventsB is None ). Note that negative indices are accepted and count from the end, as usual in Python. Arguments i : int The index of an event from eventsA . An IndexError is raised if it is out of range. j : int The index of an event from eventsB , or eventsA if eventsB was None . An IndexError is raised if it is out of range. Returns float The Wasserstein distance between the specified events.","title":"emd"},{"location":"docs/emds/#neva","text":"nevA () Returns int The number of events in dataset A.","title":"nevA"},{"location":"docs/emds/#nevb","text":"nevB () If eventsB was None , this will be the same as nevA . Returns int The number of events in dataset B.","title":"nevB"},{"location":"docs/emds/#num_emds","text":"num_emds () Returns int The number of unique EMD computations carried out.","title":"num_emds"},{"location":"docs/emds/#duration","text":"duration () Returns float The wall time, in seconds, of the previous computation.","title":"duration"},{"location":"docs/emds/#errored","text":"errored () Whether or not any individual computations had a non-zero return status, indicating an error. Returns bool Whether any errors occurred among the computations.","title":"errored"},{"location":"docs/emds/#error_messages","text":"error_messages () Error messages, if any, that have occurred during the computations. Returns list of str A list of the error messages for anything that went wrong during the computations. An empty list means there were no errors.","title":"error_messages"},{"location":"docs/emds/#getset-options","text":"These methods can be used to get the current settings of the PairwiseEMD object or to set new ones. The getter methods are: R() : returns float beta() : returns float norm() : returns bool omp_dynamic_chunksize() : returns int The number of EMD computations spooled to each thread at a time. external_handler() : returns bool This will be True if there is an external EMD handler associated with the PairwiseEMD object and False otherwise. The setter methods are: set_R(new_R) : accepts float set_beta(new_beta) : accepts float set_norm(new_norm) : accepts bool set_network_simplex_params(n_iter_max=100000, epsilon_large_factor=10000.0, epsilon_small_factor=1.0) This method resets all of the underlying network simplex solver's parameters at once. set_omp_dynamic_chunksize(new_chunksize) : accepts int Sets the number of EMD evaluations spooled to each thread at a time.","title":"Get/Set Options"},{"location":"docs/emds/#set_external_emd_handler","text":"set_external_emd_handler ( emd_handler ) Associates this PairwiseEMD object with an ExternalEMDHandler . The results of the EMD computations will not be internally stored but will be passed on to the handler in a thread-safe manner for processing. Arguments emd_handler : ExternalEMDHandler An instance of ExternalEMDHandler that processes EMD values in an online manner.","title":"set_external_emd_handler"},{"location":"docs/emds/#other-methods","text":"","title":"Other Methods"},{"location":"docs/emds/#description","text":"description ( write_preprocessors = True ) Returns a string that describes the PairwiseEMD object. Printing the PairwiseEMD object uses this method to describe the object. Arguments write_preprocessors : bool Whether or not to include preprocessors in the description. There are currently no preprocessors included in the Wasserstein package but this may change in the future. Returns string The description of the PairwiseEMD object.","title":"description"},{"location":"docs/emds/#clear","text":"clear () Frees some memory in use by the PairwiseEMD object. This should not normally need to be called by the user, except possibly after a larger computation. Note that this also removes any external EMD handler that may be present.","title":"clear"},{"location":"docs/emds/#c","text":"The PairwiseEMD C++ class is a template class that accepts a fully-qualified EMD type parameter, from which it obtains information about event types, pairwise distance types, etc. There are two constructors: one that takes many of the same arguments as the EMD class in order to construct them internally and one that accepts a fully built EMD object. template < class EMD > emd :: PairwiseEMD ( Value R = 1 , Value beta = 1 , bool norm = false , int num_threads = -1 , long long print_every = -10 , unsigned verbose = 1 , bool store_sym_emds_flattened = true , bool throw_on_error = false , unsigned n_iter_max = 100000 , Value epsilon_large_factor = 10000 , Value epsilon_small_factor = 1 , std :: ostream & os = std :: cout ); template < class EMD > emd :: PairwiseEMD ( const EMD & emd , int num_threads = -1 , long long print_every = -10 , unsigned verbose = 1 , bool store_sym_emds_flattened = true , bool throw_on_error = false , std :: ostream & os = std :: cout ) See the Python class of the same name for the meaning of these arguments. os is an output stream that will be used for printing if verbose .","title":"C++"},{"location":"docs/emds/#compute-distances_1","text":"The operator() and compute methods are overloaded to compute collections of EMD distances between two sets of events in different ways. Each has a one-argument version that computes all EMDs between every pair of events in the provided collection. Each also has a two-argument version that computes all EMDs between pairs of events with one from each set. Just as with the EMD methods of the same name, the operator() methods accept \"proto events\" (which may be of type Event or are something that Event can be constructed from) that will be preprocessed and compute accepts fully-constructed events that will not be preprocessed.","title":"Compute Distances"},{"location":"docs/emds/#operator","text":"template < class ProtoEvent > void operator ()( const std :: vector < ProtoEvent > & proto_events ); template < class ProtoEventA , class ProtoEventB > void operator ()( const std :: vector < ProtoEventA > & proto_eventsA , const std :: vector < ProtoEventB > & proto_eventsB ); This version preprocesses each event to ensure any preprocessors are called and the weights are normalized properly (if norm=true ). Arguments proto_events[A/B] Collection of proto events; the actual events will be obtained by calling Event(proto_event) for each proto_event in the vector.","title":"operator()"},{"location":"docs/emds/#compute","text":"void compute ( const std :: vector < Event > & events ); void compute ( const std :: vector < Event > & eventsA , const std :: vector < Event > & eventsB ); This version does not apply any preprocessing. Arguments events[A/B] Collection of fully-constructed events.","title":"compute"},{"location":"docs/emds/#access-results_1","text":"Many of the methods share the same names as the Python ones . These are: const std :: vector < Value > & emds ( bool raw = false ); const std :: vector < Event > & events () const ; Value emd ( long long i , long long j ) const ; size_t nevA () const ; size_t nevB () const ; size_t num_emds () const ; double duration () const ; bool errored () const ; const std :: vector < std :: string > & error_messages () const ; The emds method returns a reference to a vector of the EMD results, where the distance matrix has been flattened into a nevA()*nevB() -sized vector in row-major (C-style) order. If only a single set of events was passed and raw=true then the non-symmetrized results of size nevA()*(nevA()-1)/2 are returned. This throws an error if there was an external EMD handler present. The events method returns a const reference to the vector of events that was used for the computations.","title":"Access Results"},{"location":"docs/emds/#getset-options_1","text":"These methods can be used to get the current settings of the EMD object or to set new ones. The getter methods are: Value R () const ; Value beta () const ; bool norm () const ; bool external_handler () const ; int omp_dynamic_chunksize () const ; external_dists() indicates whether or not to use the internal PairwiseDistance object or to assume that the ground distances have been externally set. network_simplex() and pairwise_distance() access the underlying objects used to do the heavy lifting of the computation. The setter methods are: void set_R ( Value R ); void set_beta ( Value beta ); void set_norm ( bool norm ); void set_external_emd_handler ( ExternalEMDHandler & handler ); void set_omp_dynamic_chunksize ( int chunksize ); void set_network_simplex_params ( unsigned n_iter_max = 100000 , Value epsilon_large_factor = 10000 , Value epsilon_small_factor = 1 ); See External EMD Handlers for more details.","title":"Get/Set Options"},{"location":"docs/emds/#other-methods_1","text":"","title":"Other Methods"},{"location":"docs/emds/#preprocess","text":"template < template < class > class P , typename ... Args > PairwiseEMD & preprocess ( Args && ... args ) Adds a preprocessor to the internal list. Each event will be preprocessed by the preprocessors in the order they were given. Currently, there is one preprocessor as part of Wasserstein, CenterWeightedCentroid . Since this preprocessor takes no arguments, it can be added as: pairwise_emd_obj . preprocess < emd :: CenterWeightedCentroid > () In general, any arguments to the preprocessor class are given as arguments to this method. A reference to the PairwiseEMD object is returned.","title":"preprocess"},{"location":"docs/emds/#description_1","text":"std :: string description () Returns A string that describes the PairwiseEMD object.","title":"description"},{"location":"docs/emds/#clear_1","text":"void clear () Frees some memory in use by the PairwiseEMD object. This should not normally need to be called by the user.","title":"clear"},{"location":"docs/externalemdhandler/","text":"External EMD Handlers Python ExternalEMDHandler Base class for all external EMD handlers. Should never be directly instantiated. This takes care of thread safety and tracks the number of calls to the handler. num_calls num_calls () Returns int The number of times that the handler has been called. description description () str A string describing the handler. Histogram1DHandler Histograms the EMD values into a pre-determined histogram. Histogram1DHandler uses a linearly-spaced axis whereas Histogram1DHandlerLog uses a log-spaced axis. This wraps the C++ class, which itself uses the Boost Histogram Package . wasserstein . Histogram1DHandler ( axis_min , axis_max , nbins ) wasserstein . Histogram1DHandlerLog ( axis_min , axis_max , nbins ) Arguments axis_min : float The lower bound of the axis. axis_max : float The upper bound of the axis. nbins : int The number of bins to create in the histogram. hist_vals_errs hist_vals_errs ( overflows = True ) This accesses the histogram values and errors (which are the squqare root of the sum of the squared weights). Arguments overflows : bool Wether or not to include the overflow bins as the first and last entry of the histogram contents and errors. Returns ( numpy.ndarray , numpy.ndarray ) A pair of numpy arrays, the first is the values of the histogram and the second is the errors. If overflows is True then each will have length nbins+2 , otherwise they will have length nbins . bin_centers bin_centers () Returns numpy.ndarray The centers of each of the bins as a nbins length numpy array. For the linearly-spaced axis this is the arithmetic mean of the bin edges and for the log-spaced axis this is the geometric mean of the bin edges. bin_edges bin_edges () Returns numpy.ndarray The bin edges as a nbins+1 length numpy array. print_axis print_axis () Returns str A textual representation of the histogram axis. print_hist print_hist () Returns str A textual representation of the histogram. axis_min axis_min () Returns float The lower bound of the histogram axis. axis_max axis_max () Returns float The upper bound of the histogram axis. nbins nbins () Returns int The number of bins of the histogram axis. CorrelationDimension This class inherits from Histogram1DHandlerLog and can be used to compute the correlation dimension of the collection of EMDs. wasserstein . CorrelationDimension ( axis_min , axis_max , nbins ) Arguments Same as those of Histogram1DHandlerLog corrdims corrdims ( eps = 1e-100 ) Arguments eps : float The epsilon value to use to avoid dividing by zero or taking the log of zero. Returns ( numpy.ndarray , numpy.ndarray ) A pair of numpy arrays, the first is the correlation dimension values and the second is the correlation dimension errors. Each of these will be length nbins-1 because a derivative was taken. corrdim_bins corrdim_bins () The EMD bins corresponding to the correlation dimension values and errors returned by corrdims . Returns numpy.ndarray The distance scales of the correlation dimension values. This has length nbins-1 because a derivative was taken. cumulative_vals_vars cumulative_vals_vars () Accesses, the raw cumulative histogram of EMD values and their variances, excluding the overflow bins. Returns ( numpy.ndarray , numpy.ndarray ) A pair of numpy arrays, the first is the cumulative EMD histogram values and the second is the variances of these bins. Each of these will be length nbins . C++","title":"External EMD Handlers"},{"location":"docs/externalemdhandler/#external-emd-handlers","text":"","title":"External EMD Handlers"},{"location":"docs/externalemdhandler/#python","text":"","title":"Python"},{"location":"docs/externalemdhandler/#externalemdhandler","text":"Base class for all external EMD handlers. Should never be directly instantiated. This takes care of thread safety and tracks the number of calls to the handler.","title":"ExternalEMDHandler"},{"location":"docs/externalemdhandler/#num_calls","text":"num_calls () Returns int The number of times that the handler has been called.","title":"num_calls"},{"location":"docs/externalemdhandler/#description","text":"description () str A string describing the handler.","title":"description"},{"location":"docs/externalemdhandler/#histogram1dhandler","text":"Histograms the EMD values into a pre-determined histogram. Histogram1DHandler uses a linearly-spaced axis whereas Histogram1DHandlerLog uses a log-spaced axis. This wraps the C++ class, which itself uses the Boost Histogram Package . wasserstein . Histogram1DHandler ( axis_min , axis_max , nbins ) wasserstein . Histogram1DHandlerLog ( axis_min , axis_max , nbins ) Arguments axis_min : float The lower bound of the axis. axis_max : float The upper bound of the axis. nbins : int The number of bins to create in the histogram.","title":"Histogram1DHandler"},{"location":"docs/externalemdhandler/#hist_vals_errs","text":"hist_vals_errs ( overflows = True ) This accesses the histogram values and errors (which are the squqare root of the sum of the squared weights). Arguments overflows : bool Wether or not to include the overflow bins as the first and last entry of the histogram contents and errors. Returns ( numpy.ndarray , numpy.ndarray ) A pair of numpy arrays, the first is the values of the histogram and the second is the errors. If overflows is True then each will have length nbins+2 , otherwise they will have length nbins .","title":"hist_vals_errs"},{"location":"docs/externalemdhandler/#bin_centers","text":"bin_centers () Returns numpy.ndarray The centers of each of the bins as a nbins length numpy array. For the linearly-spaced axis this is the arithmetic mean of the bin edges and for the log-spaced axis this is the geometric mean of the bin edges.","title":"bin_centers"},{"location":"docs/externalemdhandler/#bin_edges","text":"bin_edges () Returns numpy.ndarray The bin edges as a nbins+1 length numpy array.","title":"bin_edges"},{"location":"docs/externalemdhandler/#print_axis","text":"print_axis () Returns str A textual representation of the histogram axis.","title":"print_axis"},{"location":"docs/externalemdhandler/#print_hist","text":"print_hist () Returns str A textual representation of the histogram.","title":"print_hist"},{"location":"docs/externalemdhandler/#axis_min","text":"axis_min () Returns float The lower bound of the histogram axis.","title":"axis_min"},{"location":"docs/externalemdhandler/#axis_max","text":"axis_max () Returns float The upper bound of the histogram axis.","title":"axis_max"},{"location":"docs/externalemdhandler/#nbins","text":"nbins () Returns int The number of bins of the histogram axis.","title":"nbins"},{"location":"docs/externalemdhandler/#correlationdimension","text":"This class inherits from Histogram1DHandlerLog and can be used to compute the correlation dimension of the collection of EMDs. wasserstein . CorrelationDimension ( axis_min , axis_max , nbins ) Arguments Same as those of Histogram1DHandlerLog","title":"CorrelationDimension"},{"location":"docs/externalemdhandler/#corrdims","text":"corrdims ( eps = 1e-100 ) Arguments eps : float The epsilon value to use to avoid dividing by zero or taking the log of zero. Returns ( numpy.ndarray , numpy.ndarray ) A pair of numpy arrays, the first is the correlation dimension values and the second is the correlation dimension errors. Each of these will be length nbins-1 because a derivative was taken.","title":"corrdims"},{"location":"docs/externalemdhandler/#corrdim_bins","text":"corrdim_bins () The EMD bins corresponding to the correlation dimension values and errors returned by corrdims . Returns numpy.ndarray The distance scales of the correlation dimension values. This has length nbins-1 because a derivative was taken.","title":"corrdim_bins"},{"location":"docs/externalemdhandler/#cumulative_vals_vars","text":"cumulative_vals_vars () Accesses, the raw cumulative histogram of EMD values and their variances, excluding the overflow bins. Returns ( numpy.ndarray , numpy.ndarray ) A pair of numpy arrays, the first is the cumulative EMD histogram values and the second is the variances of these bins. Each of these will be length nbins .","title":"cumulative_vals_vars"},{"location":"docs/externalemdhandler/#c","text":"","title":"C++"},{"location":"docs/utils/","text":"Utils Python check_emd_status wasserstein . check_emd_status ( status ) Examines the return status of an EMD computation and raises an appropriate RuntimeError if it is not 0 . Arguments status : int The status of the EMD computation. Zero means success and non-zero values indicate some sort of failure. phi_fix wasserstein . phi_fix ( phi , ref_phi ) Ensures that phi is within \\pi \\pi of ref_phi . Arguments phi : float An azimuthal angle. ref_phi : float A reference azimuthal angle that should be numerically within 2\\pi 2\\pi of phi , which is always satisfied if both phi and ref_phi are in a standard range like [0,2\\pi) [0,2\\pi) . C++ CenterWeightedCentroid","title":"Utils"},{"location":"docs/utils/#utils","text":"","title":"Utils"},{"location":"docs/utils/#python","text":"","title":"Python"},{"location":"docs/utils/#check_emd_status","text":"wasserstein . check_emd_status ( status ) Examines the return status of an EMD computation and raises an appropriate RuntimeError if it is not 0 . Arguments status : int The status of the EMD computation. Zero means success and non-zero values indicate some sort of failure.","title":"check_emd_status"},{"location":"docs/utils/#phi_fix","text":"wasserstein . phi_fix ( phi , ref_phi ) Ensures that phi is within \\pi \\pi of ref_phi . Arguments phi : float An azimuthal angle. ref_phi : float A reference azimuthal angle that should be numerically within 2\\pi 2\\pi of phi , which is always satisfied if both phi and ref_phi are in a standard range like [0,2\\pi) [0,2\\pi) .","title":"phi_fix"},{"location":"docs/utils/#c","text":"","title":"C++"},{"location":"docs/utils/#centerweightedcentroid","text":"","title":"CenterWeightedCentroid"}]}